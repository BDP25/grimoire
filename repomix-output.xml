This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    lint.yml
    test.yml
grimoire/
  helpers/
    ingestion.py
    llm.py
    retriever.py
    typer.py
    vectorstore.py
  __init__.py
  ask.py
  configuration.py
  flush.py
  init.py
  main.py
  sync.py
  update.py
  verify.py
images/
  logo.svg
sandbox/
  files/
    configuration.md
    customizing-your-theme.md
    drag-n-drop.html
    geom.py
    getting-started.md
    hello.py
    script.js
    styles.css
    vilko.md
    writing-your-docs.md
  code_ingestion_01.py
  code_ingestion_02.py
  code_ingestion.py
  helpers.py
  repo_clone.py
  retrieval_chain.py
  text_ingestion_01.py
  text_ingestion_02.py
  text_ingestion_03.py
  text_ingestion.py
tests/
  test_ask.py
  test_init.py
  test_main.py
.editorconfig
.gitignore
.pylintrc
compose.yaml
CONTRIBUTING.md
grimoire.yaml
LICENSE.md
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/test_ask.py">
import os
from unittest.mock import MagicMock, patch

from typer.testing import CliRunner

from grimoire.main import cli

runner = CliRunner()


@patch.dict(os.environ, {}, clear=True)
def test_ask_fails_without_llm_api_key():
    result = runner.invoke(cli, ["ask", "What", "is", "this?"])
    assert result.exit_code != 0
    assert "LLM_API_KEY environment variable is not set." in result.stdout


@patch.dict(os.environ, {"LLM_API_KEY": "fake-key"})
@patch("grimoire.helpers.llm.setup_llm")
def test_ask_with_skip_rag_uses_only_llm(mock_setup_llm):
    mock_llm = MagicMock()
    mock_llm.stream.return_value = [MagicMock(content="LLM response.")]
    mock_setup_llm.return_value = mock_llm

    result = runner.invoke(cli, ["ask", "My dummy question?", "--skip-rag"])
    assert result.exit_code == 0
    assert "LLM response." in result.stdout
    mock_llm.stream.assert_called_once_with("Test question")
</file>

<file path="grimoire/helpers/typer.py">
import typer


def blue_text(text: str, bold: bool = True) -> str:
    """
    Returns the text in blue color

    :param text: text to color
    :param bold: whether to make the text bold
    :return: colored text
    """
    return typer.style(text, fg=typer.colors.BLUE, bold=bold)


def red_text(text: str, bold: bool = True) -> str:
    """
    Returns the text in red color

    :param text: text to color
    :param bold: whether to make the text bold
    :return: colored text
    """
    return typer.style(text, fg=typer.colors.RED, bold=bold)


def green_text(text: str, bold: bool = True) -> str:
    """
    Returns the text in green color

    :param text: text to color
    :param bold: whether to make the text bold
    :return: colored text
    """
    return typer.style(text, fg=typer.colors.GREEN, bold=bold)
</file>

<file path="images/logo.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->

<svg
   fill="#000000"
   width="800px"
   height="800px"
   viewBox="0 0 32 32"
   version="1.1"
   id="svg4"
   sodipodi:docname="flask.svg"
   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs4" />
  <sodipodi:namedview
     id="namedview4"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:zoom="0.46019408"
     inkscape:cx="526.95158"
     inkscape:cy="655.15836"
     inkscape:window-width="1104"
     inkscape:window-height="1242"
     inkscape:window-x="7"
     inkscape:window-y="52"
     inkscape:window-maximized="0"
     inkscape:current-layer="Layer_2" />
  <title
     id="title1" />
  <g
     data-name="Layer 2"
     id="Layer_2">
    <path
       d="M26,19.72a10,10,0,0,0-6-8.88V8h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2h1v2.84a10,10,0,0,0-5.84,7.44A9,9,0,0,0,6,20a2.62,2.62,0,0,0,0,.28,10,10,0,0,0,19.84,1.44A9.74,9.74,0,0,0,26,20,2.62,2.62,0,0,0,26,19.72Zm-2.16,1.93A8,8,0,0,1,8,20.36c0-.12,0-.24,0-.36a7.43,7.43,0,0,1,.18-1.64,8,8,0,0,1,5.15-5.89,1,1,0,0,0,.67-1V8h4v3.52a1,1,0,0,0,.67,1A8,8,0,0,1,24,19.64,2.17,2.17,0,0,1,24,20,8.17,8.17,0,0,1,23.83,21.65Z"
       id="path1"
       style="stroke:none;stroke-opacity:1;fill:#073b4c;fill-opacity:1" />
    <path
       d="M22,20a6,6,0,0,1-12,0,5.29,5.29,0,0,1,.1-1.06l.33.16a5.12,5.12,0,0,0,2.57.62,5.12,5.12,0,0,0,2.57-.62A6.84,6.84,0,0,1,19,18.28a6.75,6.75,0,0,1,2.89.57A6.23,6.23,0,0,1,22,20Z"
       id="path2"
       style="fill:#ef476f;fill-opacity:1" />
    <path
       d="m 8,8 c -0.00539,0.4119621 -0.3380379,0.7446142 -0.75,0.75 -0.8261577,0.00545 -1.4945466,0.6738423 -1.5,1.5 0,1 -1.5,1 -1.5,0 0,-0.8284271 -0.6715729,-1.5 -1.5,-1.5 -0.9999996,0 -0.9999996,-1.5 0,-1.5 0.8284271,0 1.5,-0.6715729 1.5,-1.5 0,-0.9999996 1.5,-0.9999996 1.5,0 0.00545,0.8261577 0.6738423,1.4945466 1.5,1.5 C 7.6619621,7.2553858 7.9946142,7.5880379 8,8 Z"
       id="path3"
       style="fill:#ef476f;fill-opacity:1"
       sodipodi:nodetypes="cccssssccc" />
    <path
       d="m 30,5 c -0.0054,0.4119621 -0.338038,0.7446142 -0.75,0.75 -0.826158,0.00545 -1.494547,0.6738423 -1.5,1.5 0,0.9999996 -1.5,0.9999996 -1.5,0 0,-0.8284271 -0.671573,-1.5 -1.5,-1.5 -1,0 -1,-1.5 0,-1.5 0.828427,0 1.5,-0.6715729 1.5,-1.5 0,-0.9999996 1.5,-0.9999996 1.5,0 0.0055,0.8261577 0.673842,1.4945466 1.5,1.5 0.411962,0.00539 0.744614,0.3380379 0.75,0.75 z"
       id="path4"
       style="fill:#ef476f;fill-opacity:1"
       sodipodi:nodetypes="cccssssccc" />
  </g>
</svg>
</file>

<file path="sandbox/files/configuration.md">
# Configuration

Guide to all available configuration settings.

---

## Introduction

Project settings are configured by default using a YAML configuration file in
the project directory named `mkdocs.yml`. You can specify another path for it
by using the `-f`/`--config-file` option (see `mkdocs build --help`).

At a minimum, this configuration file must contain the `site_name`. All other settings are optional.

## Project information

### site_name

This is a **required setting**, and should be a string that is used as the main
title for the project documentation. For example:

```yaml
site_name: Marshmallow Generator
```

When rendering the theme this setting will be passed as the `site_name` context
variable.

### site_url

Set the canonical URL of the site. This will add a `link` tag with the
`canonical` URL to the `head` section of each HTML page. If the 'root' of the
MkDocs site will be within a subdirectory of a domain, be sure to include that
subdirectory in the setting (`https://example.com/foo/`).

This setting is also used for `mkdocs serve`: the server will be mounted onto a
path taken from the path component of the URL, e.g. `some/page.md` will be
served from `http://127.0.0.1:8000/foo/some/page/` to mimic the expected remote
layout.

**default**: `null`

### repo_url

When set, provides a link to your repository (GitHub, Bitbucket, GitLab, ...)
on each page.

```yaml
repo_url: https://github.com/example/repository/
```

**default**: `null`

### repo_name

When set, provides the name for the link to your repository on each page.

**default**: `'GitHub'`, `'Bitbucket'` or `'GitLab'` if the `repo_url` matches
those domains, otherwise the hostname from the `repo_url`.

### edit_uri

The path from the base `repo_url` to the docs directory when directly viewing a
page, accounting for specifics of the repository host (e.g. GitHub, Bitbucket,
etc), the branch, and the docs directory itself. MkDocs concatenates `repo_url`
and `edit_uri`, and appends the input path of the page.

When set, and if your theme supports it, provides a link directly to the page in
your source repository. This makes it easier to find and edit the source for the
page. If `repo_url` is not set, this option is ignored. On some themes, setting
this option may cause an edit link to be used in place of a repository link.
Other themes may show both links.

The `edit_uri` supports query ('?') and fragment ('#') characters. For
repository hosts that use a query or a fragment to access the files, the
`edit_uri` might be set as follows. (Note the `?` and `#` in the URI...)

```yaml
# Query string example
edit_uri: '?query=root/path/docs/'
```

```yaml
# Hash fragment example
edit_uri: '#root/path/docs/'
```

For other repository hosts, simply specify the relative path to the docs
directory.

```yaml
# Query string example
edit_uri: root/path/docs/
```

For example, having this config:

```yaml
repo_url: https://example.com/project/repo
edit_uri: blob/main/docs/
```

means that a page named 'foo/bar.md' will have its edit link lead to:  
<https://example.com/project/repo/blob/main/docs/foo/bar.md>

`edit_uri` can actually be just an absolute URL, not necessarily relative to `repo_url`, so this can achieve the same result:

```yaml
edit_uri: https://example.com/project/repo/blob/main/docs/
```

For more flexibility, see [edit_uri_template](#edit_uri_template) below.

> NOTE:
> On a few known hosts (specifically GitHub, Bitbucket and GitLab), the
> `edit_uri` is derived from the 'repo_url' and does not need to be set
> manually. Simply defining a `repo_url` will automatically populate the
> `edit_uri` configs setting.
>
> For example, for a GitHub- or GitLab-hosted repository, the `edit_uri`
> would be automatically set as `edit/master/docs/` (Note the `edit` path
> and `master` branch).
>
> For a Bitbucket-hosted repository, the equivalent `edit_uri` would be
> automatically set as `src/default/docs/` (note the `src` path and `default`
> branch).
>
> To use a different URI than the default (for example a different branch),
> simply set the `edit_uri` to your desired string. If you do not want any
> "edit URL link" displayed on your pages, then set `edit_uri` to an empty
> string to disable the automatic setting.

WARNING:
On GitHub and GitLab, the default "edit" path (`edit/master/docs/`) opens
the page in the online editor. This functionality requires that the user
have and be logged in to a GitHub/GitLab account. Otherwise, the user will
be redirected to a login/signup page. Alternatively, use the "blob" path
(`blob/master/docs/`) to open a read-only view, which supports anonymous
access.

**default**: `edit/master/docs/` for GitHub and GitLab repos or
`src/default/docs/` for a Bitbucket repo, if `repo_url` matches those domains,
otherwise `null`

### edit_uri_template

The more flexible variant of [edit_uri](#edit_uri). These two are equivalent:

```yaml
edit_uri: 'blob/main/docs/'
edit_uri_template: 'blob/main/docs/{path}'
```

(they are also mutually exclusive -- don't specify both).

Starting from here, you can change the positioning or formatting of the path, in case the default behavior of appending the path isn't enough.

The contents of `edit_uri_template` are normal [Python format strings](https://docs.python.org/3/library/string.html#formatstrings), with only these fields available:

* `{path}`, e.g. `foo/bar.md`
* `{path_noext}`, e.g. `foo/bar`

And the conversion flag `!q` is available, to percent-encode the field:

* `{path!q}`, e.g. `foo%2Fbar.md`

>? NOTE: **Suggested useful configurations:**
>
> *   GitHub Wiki:  
>     (e.g. `https://github.com/project/repo/wiki/foo/bar/_edit`)
>
>     ```yaml
>     repo_url: 'https://github.com/project/repo/wiki'
>     edit_uri_template: '{path_noext}/_edit'
>     ```
>
> *   BitBucket editor:  
>     (e.g. `https://bitbucket.org/project/repo/src/master/docs/foo/bar.md?mode=edit`)
>
>     ```yaml
>     repo_url: 'https://bitbucket.org/project/repo/'
>     edit_uri_template: 'src/master/docs/{path}?mode=edit'
>     ```
>
> *   GitLab Static Site Editor:  
>     (e.g. `https://gitlab.com/project/repo/-/sse/master/docs%2Ffoo%2bar.md`)
>
>     ```yaml
>     repo_url: 'https://gitlab.com/project/repo'
>     edit_uri_template: '-/sse/master/docs%2F{path!q}'
>     ```
>
> *   GitLab Web IDE:  
>     (e.g. `https://gitlab.com/-/ide/project/repo/edit/master/-/docs/foo/bar.md`)
>
>     ```yaml
>     edit_uri_template: 'https://gitlab.com/-/ide/project/repo/edit/master/-/docs/{path}'
>     ```

**default**: `null`

### site_description

Set the site description. This will add a meta tag to the generated HTML header.

**default**: `null`

### site_author

Set the name of the author. This will add a meta tag to the generated HTML
header.

**default**: `null`

### copyright

Set the copyright information to be included in the documentation by the theme.

**default**: `null`

### remote_branch

Set the remote branch to commit to when using `gh-deploy` to deploy to GitHub
Pages. This option can be overridden by a command line option in `gh-deploy`.

**default**: `gh-pages`

### remote_name

Set the remote name to push to when using `gh-deploy` to deploy to GitHub Pages.
This option can be overridden by a command line option in `gh-deploy`.

**default**: `origin`

## Documentation layout

### nav

This setting is used to determine the format and layout of the global navigation
for the site. A minimal navigation configuration could look like this:

```yaml
nav:
  - 'index.md'
  - 'about.md'
```

All paths in the navigation configuration must be relative to the
[`docs_dir`](#docs_dir) configuration option. See the section on [configuring
pages and navigation] for a more detailed breakdown, including how to create
sub-sections.

Navigation items may also include links to external sites. While titles are
optional for internal links, they are required for external links. An external
link may be a full URL or a relative URL. Any path which is not found in the
files is assumed to be an external link. See the section about [Meta-Data] on
how MkDocs determines the page title of a document.

```yaml
nav:
  - Introduction: 'index.md'
  - 'about.md'
  - 'Issue Tracker': 'https://example.com/'
```

In the above example, the first two items point to local files while the third
points to an external site.

However, sometimes the MkDocs site is hosted in a subdirectory of a project's
site and you may want to link to other parts of the same site without including
the full domain. In that case, you may use an appropriate relative URL.

```yaml
site_url: https://example.com/foo/

nav:
  - Home: '../'
  - 'User Guide': 'user-guide.md'
  - 'Bug Tracker': '/bugs/'
```

In the above example, two different styles of external links are used. First,
note that the `site_url` indicates that the MkDocs site is hosted in the `/foo/`
subdirectory of the domain. Therefore, the `Home` navigation item is a relative
link that steps up one level to the server root and effectively points to
`https://example.com/`. The `Bug Tracker` item uses an absolute path from the
server root and effectively points to `https://example.com/bugs/`. Of course, the
`User Guide` points to a local MkDocs page.

**default**: By default `nav` will contain an alphanumerically sorted, nested
list of all the Markdown files found within the `docs_dir` and its
sub-directories. Index files will always be listed first within a sub-section.

### exclude_docs

NEW: **New in version 1.5.**

> DANGER: **Changed in version 1.6:**
>
> This config no longer applies the "drafts" functionality for `mkdocs serve`. If you have draft documents that you want available in "serve" and not "build", replace `exclude_docs` with the new [`draft_docs`](#draft_docs) config option.

This config defines patterns of files (under [`docs_dir`](#docs_dir)) to not be picked up into the built site.

Example:

```yaml
exclude_docs: |
  # A file with this name anywhere.
  api-config.json

  # Top-level "docs/requirements.txt".
  /requirements.txt

  # Any file with this extension anywhere.
  *.py

  # But keep this particular file.
  !/foo/example.py
```

This follows the [.gitignore pattern format](https://git-scm.com/docs/gitignore#_pattern_format).

The following defaults are always implicitly prepended - to exclude dot-files (and directories) as well as the top-level `templates` directory:

```yaml
exclude_docs: |
  .*
  /templates/
```

So, in order to really start this config fresh, you'd need to specify a negated version of these entries first.

Otherwise you could for example opt only certain dot-files back into the site:

```yaml
exclude_docs: |
  # Don't exclude '.assets' although all other '.*' are excluded
  !.assets
```

### draft_docs

NEW: **New in version 1.6.**

This config defines patterns of files (under [`docs_dir`](#docs_dir)) to be treated as a draft.  Draft files are available during `mkdocs serve` and include a "DRAFT" mark but will not be included in the build. To prevent this effect and make "serve" behave the same as "build", you can run `mkdocs serve --clean`.

Example:

```yaml
draft_docs: |
  # A "drafts" directory anywhere.
  drafts/

  # A Markdown file ending in _unpublished.md anywhere.
  *_unpublished.md

  # But keep this particular file.
  !/foo_unpublished.md
```

This follows the [.gitignore pattern format](https://git-scm.com/docs/gitignore#_pattern_format).

### not_in_nav

NEW: **New in version 1.5.**

> NEW: **New in version 1.6:**
>
> If the [`nav`](#nav) config is not specified at all, pages specified in this config will now be excluded from the inferred navigation.

If you want to include some docs into the site but intentionally exclude them from the nav, normally MkDocs warns about this.

Adding such patterns of files (relative to [`docs_dir`](#docs_dir)) into the `not_in_nav` config will prevent such warnings.

Example:

```yaml
nav:
  - Foo: foo.md
  - Bar: bar.md

not_in_nav: |
  /private.md
```

As the previous option, this follows the .gitignore pattern format.

NOTE: Adding a given file to [`exclude_docs`](#exclude_docs) takes precedence over and implies `not_in_nav`.

### validation

NEW: **New in version 1.5.**

Configure the strictness of MkDocs' diagnostic messages when validating links to documents.

This is a tree of configs, and for each one the value can be one of the three: `warn`, `info`, `ignore`. Which cause a logging message of the corresponding severity to be produced. The `warn` level is, of course, intended for use with `mkdocs build --strict` (where it becomes an error), which you can employ in continuous testing.

The config `validation.links.absolute_links` additionally has a special value `relative_to_docs`, for [validation of absolute links](#validation-of-absolute-links).

>? EXAMPLE: **Defaults of this config as of MkDocs 1.6:**
>
> ```yaml
> validation:
>   nav:
>     omitted_files: info
>     not_found: warn
>     absolute_links: info
>   links:
>     not_found: warn
>     anchors: info
>     absolute_links: info
>     unrecognized_links: info
> ```
>
> (Note: you shouldn't copy this whole example, because it only duplicates the defaults. Only individual items that differ should be set.)

The defaults of some of the behaviors already differ from MkDocs 1.4 and below - they were ignored before.

>? EXAMPLE: **Configure MkDocs 1.6 to behave like MkDocs 1.4 and below (reduce strictness):**
>
> ```yaml
> validation:
>   absolute_links: ignore
>   unrecognized_links: ignore
>   anchors: ignore
> ```
<!-- -->
>! EXAMPLE: **Recommended settings for most sites (maximal strictness):**
>
> ```yaml
> validation:
>   omitted_files: warn
>   absolute_links: warn  # Or 'relative_to_docs' - new in MkDocs 1.6
>   unrecognized_links: warn
>   anchors: warn  # New in MkDocs 1.6
> ```

Note how in the above examples we omitted the 'nav' and 'links' keys. Here `absolute_links:` means setting both `nav: absolute_links:` and `links: absolute_links:`.

Full list of values and examples of log messages that they can hide or make more prominent:

*   `validation.nav.omitted_files`
    * > The following pages exist in the docs directory, but are not included in the "nav" configuration: ...
*   `validation.nav.not_found`
    * > A reference to 'foo/bar.md' is included in the 'nav' configuration, which is not found in the documentation files.
    * > A reference to 'foo/bar.md' is included in the 'nav' configuration, but this file is excluded from the built site.
*   `validation.nav.absolute_links`
    * > An absolute path to '/foo/bar.html' is included in the 'nav' configuration, which presumably points to an external resource.
<!-- -->
*   `validation.links.not_found`
    * > Doc file 'example.md' contains a link '../foo/bar.md', but the target is not found among documentation files.
    * > Doc file 'example.md' contains a link to 'foo/bar.md' which is excluded from the built site.
*   `validation.links.anchors`
    * > Doc file 'example.md' contains a link '../foo/bar.md#some-heading', but the doc 'foo/bar.md' does not contain an anchor '#some-heading'.
    * > Doc file 'example.md' contains a link '#some-heading', but there is no such anchor on this page.
*   `validation.links.absolute_links`
    * > Doc file 'example.md' contains an absolute link '/foo/bar.html', it was left as is. Did you mean 'foo/bar.md'?
*   `validation.links.unrecognized_links`
    * > Doc file 'example.md' contains an unrecognized relative link '../foo/bar/', it was left as is. Did you mean 'foo/bar.md'?
    * > Doc file 'example.md' contains an unrecognized relative link 'mail\@example.com', it was left as is. Did you mean 'mailto:mail\@example.com'?

#### Validation of absolute links

NEW: **New in version 1.6.**

> Historically, within Markdown, MkDocs only recognized **relative** links that lead to another physical `*.md` document (or media file). This is a good convention to follow because then the source pages are also freely browsable without MkDocs, for example on GitHub. Whereas absolute links were left unmodified (making them often not work as expected) or, more recently, warned against. If you dislike having to always use relative links, now you can opt into absolute links and have them work correctly.

If you set the setting `validation.links.absolute_links` to the new value `relative_to_docs`, all Markdown links starting with `/` will be understood as being relative to the `docs_dir` root. The links will then be validated for correctness according to all the other rules that were already working for relative links in prior versions of MkDocs. For the HTML output, these links will still be turned relative so that the site still works reliably.

So, now any document (e.g. "dir1/foo.md") can link to the document "dir2/bar.md" as `[link](/dir2/bar.md)`, in addition to the previously only correct way `[link](../dir2/bar.md)`.

You have to enable the setting, though. The default is still to just skip the link.

> EXAMPLE: **Settings to recognize absolute links and validate them:**
>
> ```yaml
> validation:
>   links:
>     absolute_links: relative_to_docs
>     anchors: warn
>     unrecognized_links: warn
> ```

## Build directories

### theme

Sets the theme and theme specific configuration of your documentation site.
May be either a string or a set of key/value pairs.

If a string, it must be the string name of a known installed theme. For a list
of available themes visit [Choosing Your Theme].

An example set of key/value pairs might look something like this:

```yaml
theme:
  name: mkdocs
  locale: en
  custom_dir: my_theme_customizations/
  static_templates:
    - sitemap.html
  include_sidebar: false
```

If a set of key/value pairs, the following nested keys can be defined:

> BLOCK:
>
> #### name
>
> The string name of a known installed theme. For a list of available themes
> visit [Choosing Your Theme].
>
> #### locale
>
> A code representing the language of your site. See [Localizing your theme]
> for details.
>
> #### custom_dir
>
> A directory containing a custom theme. This can either be a relative
> directory, in which case it is resolved relative to the directory containing
> your configuration file or it can be an absolute directory path from the
> root of your local file system.
>
> See [Customizing Your Theme][theme_dir] for details if you would like to tweak an
> existing theme.
>
> See the [Theme Developer Guide] if you would like to build your own theme
> from the ground up.
>
> #### static_templates
>
> A list of templates to render as static pages. The templates must be located
> in either the theme's template directory or in the `custom_dir` defined in
> the theme configuration.
>
> #### (theme specific keywords)
>
> Any additional keywords supported by the theme can also be defined. See the
> documentation for the theme you are using for details.

**default**: `'mkdocs'`

### docs_dir

The directory containing the documentation source markdown files. This can
either be a relative directory, in which case it is resolved relative to the
directory containing your configuration file, or it can be an absolute directory
path from the root of your local file system.

**default**: `'docs'`

### site_dir

The directory where the output HTML and other files are created. This can either
be a relative directory, in which case it is resolved relative to the directory
containing your configuration file, or it can be an absolute directory path from
the root of your local file system.

**default**: `'site'`

> NOTE:
> If you are using source code control you will normally want to ensure that
> your *build output* files are not committed into the repository, and only
> keep the *source* files under version control. For example, if using `git`
> you might add the following line to your `.gitignore` file:
>
> ```text
> site/
> ```
>
> If you're using another source code control tool, you'll want to check its
> documentation on how to ignore specific directories.

### extra_css

Set a list of CSS files (relative to `docs_dir`) to be included by the theme, typically as `<link>` tags.

Example:

```yaml
extra_css:
  - css/extra.css
  - css/second_extra.css
```

**default**: `[]` (an empty list).

### extra_javascript

Set a list of JavaScript files in your `docs_dir` to be included by the theme, as `<script>` tags.

> NEW: **Changed in version 1.5:**
>
> Older versions of MkDocs supported only a plain list of strings, but now several additional config keys are available: `type`, `async`, `defer`.

See the examples and what they produce:

```yaml
extra_javascript:
  - some_plain_javascript.js       # <script src="some_plain_javascript.js"></script>
        # New behavior in MkDocs 1.5:
  - implicitly_as_module.mjs       # <script src="implicitly_as_module.mjs" type="module"></script>
        # Config keys only supported since MkDocs 1.5:
  - path: explicitly_as_module.mjs # <script src="explicitly_as_module.mjs" type="module"></script>
    type: module
  - path: deferred_plain.js        # <script src="deferred_plain.js" defer></script>
    defer: true
  - path: scripts/async_module.mjs # <script src="scripts/async_module.mjs" type="module" async></script>
    type: module
    async: true
```

So, each item can be either:

* a plain string, or
* a mapping that has the required `path` key and 3 optional keys `type` (string), `async` (boolean), `defer` (boolean).

Only the plain string variant detects the `.mjs` extension and adds `type="module"`, otherwise `type: module` must be written out regardless of extension.

**default**: `[]` (an empty list).

NOTE: `*.js` and `*.css` files, just like any other type of file, are always copied from `docs_dir` into the site's deployed copy, regardless if they're linked to the pages via the above configs or not.

### extra_templates

Set a list of templates in your `docs_dir` to be built by MkDocs. To see more
about writing templates for MkDocs read the documentation about [custom themes]
and specifically the section about the [available variables] to
templates. See the example in [extra_css] for usage.

**default**: `[]` (an empty list).

### extra

A set of key-value pairs, where the values can be any valid YAML construct, that
will be passed to the template. This allows for great flexibility when creating
custom themes.

For example, if you are using a theme that supports displaying the project
version, you can pass it to the theme like this:

```yaml
extra:
  version: 1.0
```

**default**: By default `extra` will be an empty key-value mapping.

## Preview controls

## Live Reloading

### watch

Determines additional directories to watch when running `mkdocs serve`.
Configuration is a YAML list.

```yaml
watch:
  - directory_a
  - directory_b
```

Allows a custom default to be set without the need to pass it through the `-w`/`--watch`
option every time the `mkdocs serve` command is called.

> NOTE:
> The paths provided via the configuration file are relative to the configuration file.
>
> The paths provided via the `-w`/`--watch` CLI parameters are not.

### use_directory_urls

This setting controls the directory structure of the generated documentation, and thereby the URL format used for linking to pages.

The following tables demonstrate how the directory structure and URLs used on the site differ when
setting `use_directory_urls` to `true` or `false`.

**`use_directory_urls: false`**

This setting is needed when the documentation is hosted on systems that can't
access the file `X/index.html` when given the URL `X`. When set to `false`,
no additional `X` directory is created, and the file is simply stored as `X.html`.
Links are created that point directly to the target *file* rather than a target
*directory*.

Source file      | Generated File     | URL Format
---------------- | ------------------ | -------------------
index.md         | index.html         | /index.html
api-guide.md     | api-guide.html     | /api-guide.html
about/license.md | about/license.html | /about/license.html

For example, this needs to be set to `false` when:

* opening pages directly from the file system
* publishing the documentation to a static S3 website.

**`use_directory_urls: true`**

The default style of `use_directory_urls: true` creates more user friendly URLs,
and is usually what you'll want to use.

Source file      | Generated File            | URL Format
---------------- | ------------------------- | --------------
index.md         | /index.html               | /
api-guide.md     | /api-guide/index.html     | /api-guide/
about/license.md | /about/license/index.html | /about/license

**default**: `true`

### strict

Determines how warnings are handled. Set to `true` to halt processing when a
warning is raised. Set to `false` to print a warning and continue processing.

This is also available as a command line flag: `--strict`.

**default**: `false`

### dev_addr

Determines the address used when running `mkdocs serve`. Must be of the format
`IP:PORT`.

Allows a custom default to be set without the need to pass it through the
`--dev-addr` option every time the `mkdocs serve` command is called.

**default**: `'127.0.0.1:8000'`

See also: [site_url](#site_url).

## Formatting options

### markdown_extensions

MkDocs uses the [Python Markdown][pymkd] library to translate Markdown files
into HTML. Python Markdown supports a variety of [extensions][pymdk-extensions]
that customize how pages are formatted. This setting lets you enable a list of
extensions beyond the ones that MkDocs uses by default (`meta`, `toc`, `tables`,
and `fenced_code`).

For example, to enable the [SmartyPants typography extension][smarty], use:

```yaml
markdown_extensions:
  - smarty
```

Some extensions provide configuration options of their own. If you would like to
set any configuration options, then you can nest a key/value mapping
(`option_name: option value`) of any options that a given extension supports.
See the documentation for the extension you are using to determine what options
they support.

For example, to enable permalinks in the (included) `toc` extension, use:

```yaml
markdown_extensions:
  - toc:
      permalink: true
```

Note that a colon (`:`) must follow the extension name (`toc`) and then on a new
line the option name and value must be indented and separated by a colon. If you
would like to define multiple options for a single extension, each option must be
defined on a separate line:

```yaml
markdown_extensions:
  - toc:
      permalink: true
      separator: "_"
```

Add an additional item to the list for each extension. If you have no
configuration options to set for a specific extension, then simply omit options
for that extension:

```yaml
markdown_extensions:
  - smarty
  - toc:
      permalink: true
  - sane_lists
```

> NOTE: **Dynamic config values.**
>
> To dynamically configure the extensions, you can get the config values from [environment variables](#environment-variables) or [obtain paths](#paths-relative-to-the-current-file-or-site) of the currently rendered Markdown file or the overall MkDocs site.

In the above examples, each extension is a list item (starts with a `-`). As an
alternative, key/value pairs can be used instead. However, in that case an empty
value must be provided for extensions for which no options are defined.
Therefore, the last example above could also be defined as follows:

```yaml
markdown_extensions:
  smarty: {}
  toc:
    permalink: true
  sane_lists: {}
```

This alternative syntax is required if you intend to override some options via
[inheritance].

> NOTE: **More extensions.**
>
> The Python-Markdown documentation provides a [list of extensions][exts]
> which are available out-of-the-box. For a list of configuration options
> available for a given extension, see the documentation for that extension.
>
> You may also install and use various third party extensions ([Python-Markdown wiki], [MkDocs project catalog][catalog]). Consult
> the documentation provided by those extensions for installation instructions
> and available configuration options.

**default**: `[]` (an empty list).

### hooks

NEW: **New in version 1.4.**

A list of paths to Python scripts (relative to `mkdocs.yml`) that are loaded and used as [plugin](#plugins) instances.

For example:

```yaml
hooks:
  - my_hooks.py
```

Then the file `my_hooks.py` can contain any [plugin event handlers](../dev-guide/plugins.md#events) (without `self`), e.g.:

```python
def on_page_markdown(markdown, **kwargs):
    return markdown.replace('a', 'z')
```

>? EXAMPLE: **Advanced example:**
>
> This produces warnings based on the Markdown content (and warnings are fatal in [strict](#strict) mode):
>
> ```python
> import logging, re
> import mkdocs.plugins
>
> log = logging.getLogger('mkdocs')
>
> @mkdocs.plugins.event_priority(-50)
> def on_page_markdown(markdown, page, **kwargs):
>     path = page.file.src_uri
>     for m in re.finditer(r'\bhttp://[^) ]+', markdown):
>         log.warning(f"Documentation file '{path}' contains a non-HTTPS link: {m[0]}")
> ```

This does not enable any new abilities compared to [plugins][], it only simplifies one-off usages, as these don't need to be *installed* like plugins do.

Note that for `mkdocs serve` the hook module will *not* be reloaded on each build.

You might have seen this feature in the [mkdocs-simple-hooks plugin](https://github.com/aklajnert/mkdocs-simple-hooks). If using standard method names, it can be directly replaced, e.g.:

```diff
-plugins:
-  - mkdocs-simple-hooks:
-      hooks:
-        on_page_markdown: 'my_hooks:on_page_markdown'
+hooks:
+  - my_hooks.py
```

> NEW: **New in MkDocs 1.6.**
>
> If a hook file has a file `foo.py` adjacent to it, it can use the normal Python syntax `import foo` to access its functions.
>
> In older versions of MkDocs, a workaround was necessary to make this work - adding the path to `sys.path`.

### plugins

A list of plugins (with optional configuration settings) to use when building
the site. See the [Plugins] documentation for full details.

**default**: `['search']` (the "search" plugin included with MkDocs).

If the `plugins` config setting is defined in the `mkdocs.yml` config file, then
any defaults (such as `search`) are ignored and you need to explicitly re-enable
the defaults if you would like to continue using them:

```yaml
plugins:
  - search
  - your_other_plugin
```

To define options for a given plugin, use a nested set of key/value pairs:

```yaml
plugins:
  - search
  - your_other_plugin:
      option1: value
      option2: other value
```

To completely disable all plugins, including any defaults, set the `plugins`
setting to an empty list:

```yaml
plugins: []
```

#### `enabled` option

> NEW: **New in MkDocs 1.6.**
>
> Each plugin has its own options keys. However MkDocs also ensures that each plugin has the `enabled` boolean option. This can be used to conditionally enable a particular plugin, as in the following example:
>
> ```yaml
> plugins:
>   - search
>   - code-validator:
>       enabled: !ENV [LINT, false]
> ```
>
> See: [Environment variables](#environment-variables)

#### Alternate syntax

In the above examples, each plugin is a list item (starts with a `-`). As an
alternative, key/value pairs can be used instead. However, in that case an empty
value must be provided for plugins for which no options are defined. Therefore,
the last example above could also be defined as follows:

```yaml
plugins:
  search: {}
  your_other_plugin:
    option1: value
    option2: other value
```

This alternative syntax is required if you intend to override some options via
[inheritance].

#### Search

A search plugin is provided by default with MkDocs which uses [lunr.js] as a
search engine. The following config options are available to alter the behavior
of the search plugin:

##### **separator**

A regular expression which matches the characters used as word separators when
building the index. By default whitespace and the hyphen (`-`) are used. To add
the dot (`.`) as a word separator you might do this:

```yaml
plugins:
  - search:
      separator: '[\s\-\.]+'
```

**default**: `'[\s\-]+'`

##### **min_search_length**

An integer value that defines the minimum length for a search query. By default
searches shorter than 3 chars in length are ignored as search result quality with
short search terms are poor. However, for some use cases (such as documentation
about Message Queues which might generate searches for 'MQ') it may be preferable
to set a shorter limit.

```yaml
plugins:
  - search:
      min_search_length: 2
```

**default**: 3

##### **lang**

A list of languages to use when building the search index as identified by their
[ISO 639-1] language codes. With [Lunr Languages], the following languages are
supported:

* `ar`: Arabic
* `da`: Danish
* `nl`: Dutch
* `en`: English
* `fi`: Finnish
* `fr`: French
* `de`: German
* `hu`: Hungarian
* `it`: Italian
* `ja`: Japanese
* `no`: Norwegian
* `pt`: Portuguese
* `ro`: Romanian
* `ru`: Russian
* `es`: Spanish
* `sv`: Swedish
* `th`: Thai
* `tr`: Turkish
* `vi`: Vietnamese

You may [contribute additional languages].

WARNING:
While search does support using multiple languages together, it is best not
to add additional languages unless you really need them. Each additional
language adds significant bandwidth requirements and uses more browser
resources. Generally, it is best to keep each instance of MkDocs to a single
language.

NOTE:
Lunr Languages does not currently include support for Chinese or other Asian
languages. However, some users have reported decent results using Japanese.

**default**: The value of `theme.locale` if set, otherwise `[en]`.

##### **prebuild_index**

Optionally generates a pre-built index of all pages, which provides some
performance improvements for larger sites. Before enabling, confirm that the
theme you are using explicitly supports using a prebuilt index (the builtin
themes do). Set to `true` to enable.

WARNING:
This option requires that [Node.js] be installed and the command `node` be
on the system path. If the call to `node` fails for any reason, a warning
is issued and the build continues uninterrupted. You may use the `--strict`
flag when building to cause such a failure to raise an error instead.

NOTE:
On smaller sites, using a pre-built index is not recommended as it creates a
significant increase is bandwidth requirements with little to no noticeable
improvement to your users. However, for larger sites (hundreds of pages),
the bandwidth increase is relatively small and your users will notice a
significant improvement in search performance.

**default**: `False`

##### **indexing**

Configures what strategy the search indexer will use when building the index
for your pages. This property is particularly useful if your project is large
in scale, and the index takes up an enormous amount of disk space.

```yaml
plugins:
  - search:
      indexing: 'full'
```

###### Options

Option | Description
------ | -----------
`full` | Indexes the title, section headings, and full text of each page.
`sections` | Indexes the title and section headings of each page.
`titles` | Indexes only the title of each page.

**default**: `full`

## Special YAML tags

### Environment variables

In most cases, the value of a configuration option is set directly in the
configuration file. However, as an option, the value of a configuration option
may be set to the value of an environment variable using the `!ENV` tag. For
example, to set the value of the `site_name` option to the value of the
variable `SITE_NAME` the YAML file may contain the following:

```yaml
site_name: !ENV SITE_NAME
```

If the environment variable is not defined, then the configuration setting
would be assigned a `null` (or `None` in Python) value. A default value can be
defined as the last value in a list. Like this:

```yaml
site_name: !ENV [SITE_NAME, 'My default site name']
```

Multiple fallback variables can be used as well. Note that the last value is
not an environment variable, but must be a value to use as a default if none
of the specified environment variables are defined.

```yaml
site_name: !ENV [SITE_NAME, OTHER_NAME, 'My default site name']
```

Simple types defined within an environment variable such as string, bool,
integer, float, datestamp and null are parsed as if they were defined directly
in the YAML file, which means that the value will be converted to the
appropriate type. However, complex types such as lists and key/value pairs
cannot be defined within a single environment variable.

For more details, see the [pyyaml_env_tag](https://github.com/waylan/pyyaml-env-tag)
project.

### Paths relative to the current file or site

NEW: **New in version 1.5.**

Some Markdown extensions can benefit from knowing the path of the Markdown file that's currently being processed, or just the root path of the current site. For that, the special tag `!relative` can be used in most contexts within the config file, though the only known usecases are within [`markdown_extensions`](#markdown_extensions).

Examples of the possible values are:

```yaml
- !relative  # Relative to the directory of the current Markdown file
- !relative $docs_dir  # Path of the docs_dir
- !relative $config_dir  # Path of the directory that contains the main mkdocs.yml
- !relative $config_dir/some/child/dir  # Some subdirectory of the root config directory
```

(Here, `$docs_dir` and `$config_dir` are currently the *only* special prefixes that are recognized.)

Example:

```yaml
markdown_extensions:
  - pymdownx.snippets:
      base_path: !relative  # Relative to the current Markdown file
```

This allows the [pymdownx.snippets] extension to include files relative to the current Markdown file, which without this tag it would have no way of knowing.

> NOTE: Even for the default case, any extension's base path is technically the *current working directory* although the assumption is that it's the *directory of mkdocs.yml*. So even if you don't want the paths to be relative, to improve the default behavior, always prefer to use this idiom:
>
> ```yaml
> markdown_extensions:
>   - pymdownx.snippets:
>       base_path: !relative $config_dir  # Relative to the root directory with mkdocs.yml
> ```

## Configuration Inheritance

Generally, a single file would hold the entire configuration for a site.
However, some organizations may maintain multiple sites which all share a common
configuration across them. Rather than maintaining separate configurations for
each, the common configuration options can be defined in a parent configuration
file which each site's primary configuration file inherits.

To define the parent for a configuration file, set the `INHERIT` (all caps) key
to the path of the parent file. The path must be relative to the location of the
primary file.

For configuration options to be merged with a parent configuration, those
options must be defined as key/value pairs. Specifically, the
[markdown_extensions] and [plugins](#plugins) options must use the alternative syntax
which does not use list items (lines which start with  `-`).

For example, suppose the common (parent) configuration is defined in `base.yml`:

```yaml
theme:
  name: mkdocs
  locale: en
  highlightjs: true

markdown_extensions:
  toc:
    permalink: true
  admonition: {}
```

Then, for the "foo" site, the primary configuration file would be defined at
`foo/mkdocs.yml`:

```yml
INHERIT: ../base.yml
site_name: Foo Project
site_url: https://example.com/foo
```

When running `mkdocs build`, the file at `foo/mkdocs.yml` would be passed in as
the configuration file. MkDocs will then parse that file, retrieve and parse the
parent file `base.yml` and deep merge the two. This would result in MkDocs
receiving the following merged configuration:

```yaml
site_name: Foo Project
site_url: https://example.com/foo

theme:
  name: mkdocs
  locale: en
  highlightjs: true

markdown_extensions:
  toc:
    permalink: true
  admonition: {}
```

Deep merging allows you to add and/or override various values in your primary
configuration file. For example, suppose for one site you wanted to add support
for definition lists, use a different symbol for permalinks, and define a
different separator. In that site's primary configuration file you could do:

```yaml
INHERIT: ../base.yml
site_name: Bar Project
site_url: https://example.com/bar

markdown_extensions:
  def_list: {}
  toc:
    permalink: 
    separator: "_"
```

In that case, the above configuration would be deep merged with `base.yml` and
result in the following configuration:

```yaml
site_name: Bar Project
site_url: https://example.com/bar

theme:
  name: mkdocs
  locale: en
  highlightjs: true

markdown_extensions:
  def_list: {}
  toc:
    permalink: 
    separator: "_"
  admonition: {}
```

Notice that the `admonition` extension was retained from the parent
configuration, the `def_list` extension was added, the value of
`toc.permalink` was replaced, and the value of `toc.separator` was added.

You can replace or merge the value of any key. However, any non-key is always
replaced. Therefore, you cannot append items to a list. You must redefine the
entire list.

As the [nav] configuration is made up of nested lists, this means that you
cannot merge navigation items. Of course, you can replace the entire `nav`
configuration with a new one. However, it is generally expected that the entire
navigation would be defined in the primary configuration file for a project.

WARNING:
As a reminder, all path based configuration options must be relative to the
primary configuration file and MkDocs does not alter the paths when merging.
Therefore, defining paths in a parent file which is inherited by multiple
different sites may not work as expected. It is generally best to define
path based options in the primary configuration file only.

The inheritance can also be used as a quick way to override keys on the command line - by using stdin as the config file. For example:

```bash
echo '{INHERIT: mkdocs.yml, site_name: "Renamed site"}' | mkdocs build -f -
```

[Theme Developer Guide]: ../dev-guide/themes.md
[custom themes]: ../dev-guide/themes.md
[available variables]: ../dev-guide/themes.md#template-variables
[pymdk-extensions]: https://python-markdown.github.io/extensions/
[pymkd]: https://python-markdown.github.io/
[smarty]: https://python-markdown.github.io/extensions/smarty/
[exts]: https://python-markdown.github.io/extensions/
[Python-Markdown wiki]: https://github.com/Python-Markdown/markdown/wiki/Third-Party-Extensions
[catalog]: https://github.com/mkdocs/catalog
[configuring pages and navigation]: writing-your-docs.md#configure-pages-and-navigation
[Meta-Data]: writing-your-docs.md#meta-data
[theme_dir]: customizing-your-theme.md#using-the-theme-custom_dir
[choosing your theme]: choosing-your-theme.md
[Localizing your theme]: localizing-your-theme.md
[extra_css]: #extra_css
[Plugins]: ../dev-guide/plugins.md
[lunr.js]: https://lunrjs.com/
[ISO 639-1]: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
[Lunr Languages]: https://github.com/MihaiValentin/lunr-languages#lunr-languages-----
[contribute additional languages]: https://github.com/MihaiValentin/lunr-languages/blob/master/CONTRIBUTING.md
[Node.js]: https://nodejs.org/
[markdown_extensions]: #markdown_extensions
[nav]: #nav
[inheritance]: #configuration-inheritance
[pymdownx.snippets]: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/
</file>

<file path="sandbox/files/customizing-your-theme.md">
# Customizing Your Theme

Altering a theme to suit your needs.

---

If you would like to make a few tweaks to an existing theme, there is no need
to create your own theme from scratch. For minor tweaks which only require
some CSS and/or JavaScript, you can [use the docs_dir](#using-the-docs_dir).
However, for more complex customizations, including overriding templates, you
will need to [use the theme custom_dir](#using-the-theme-custom_dir) setting.

## Using the docs_dir

The [extra_css] and [extra_javascript] configuration options can be used to
make tweaks and customizations to existing themes. To use these, you simply
need to include either CSS or JavaScript files within your [documentation
directory].

For example, to change the color of the headers in your documentation, create
a file called (for example) `style.css` and place it next to the documentation Markdown. In
that file add the following CSS.

```css
h1 {
  color: red;
}
```

Then you need to add it to `mkdocs.yml`:

```yaml
extra_css:
  - style.css
```

After making these changes, they should be visible when you run
`mkdocs serve` - if you already had this running, you should see that the CSS
changes were automatically picked up and the documentation will be updated.

NOTE:
Any extra CSS or JavaScript files will be added to the generated HTML
document after the page content. If you desire to include a JavaScript
library, you may have better success including the library by using the
theme [custom_dir].

## Using the theme custom_dir

The [`theme.custom_dir`][custom_dir] configuration option can be used to point
to a directory of files which override the files in a parent theme. The parent
theme would be the theme defined in the [`theme.name`][name] configuration
option. Any file in the `custom_dir` with the same name as a file in the
parent theme will replace the file of the same name in the parent theme. Any
additional files in the `custom_dir` will be added to the parent theme. The
contents of the `custom_dir` should mirror the directory structure of the
parent theme. You may include templates, JavaScript files, CSS files, images,
fonts, or any other media included in a theme.

NOTE:
For this to work, the `theme.name` setting must be set to a known
installed theme. If the `name` setting is instead set to `null` (or not
defined), then there is no theme to override and the contents of the
`custom_dir` must be a complete, standalone theme. See the [Theme
Developer Guide][custom theme] for more information.

For example, the [mkdocs] theme ([browse source]), contains the following
directory structure (in part):

```text
- css\
- fonts\
- img\
  - favicon.ico
  - grid.png
- js\
- 404.html
- base.html
- content.html
- nav-sub.html
- nav.html
- toc.html
```

To override any of the files contained in that theme, create a new directory
next to your `docs_dir`:

```bash
mkdir custom_theme
```

And then point your `mkdocs.yml` configuration file at the new directory:

```yaml
theme:
  name: mkdocs
  custom_dir: custom_theme/
```

To override the 404 error page ("file not found"), add a new template file named
`404.html` to the `custom_theme` directory. For information on what can be
included in a template, review the [Theme Developer Guide][custom theme].

To override the favicon, you can add a new icon file at
`custom_theme/img/favicon.ico`.

To include a JavaScript library, copy the library to the `custom_theme/js/`
directory.

Your directory structure should now look like this:

```text
- docs/
  - index.html
- custom_theme/
  - img/
    - favicon.ico
  - js/
    - somelib.js
  - 404.html
- config.yml
```

NOTE:
Any files included in the parent theme (defined in `name`) but not
included in the `custom_dir` will still be utilized. The `custom_dir` will
only override/replace files in the parent theme. If you want to remove
files, or build a theme from scratch, then you should review the [Theme
Developer Guide][custom theme].

### Overriding Template Blocks

The built-in themes implement many of their parts inside template blocks which
can be individually overridden in the `main.html` template. Simply create a
`main.html` template file in your `custom_dir` and define replacement blocks
within that file. Just make sure that the `main.html` extends `base.html`. For
example, to alter the title of the MkDocs theme, your replacement `main.html`
template would contain the following:

```django
{% extends "base.html" %}

{% block htmltitle %}
<title>Custom title goes here</title>
{% endblock %}
```

In the above example, the `htmltitle` block defined in your custom `main.html` file
will be used in place of the default `htmltitle` block defined in the parent theme.
You may re-define as many blocks as you desire, as long as those blocks are
defined in the parent. For example, you could replace the Google Analytics
script with one for a different service or replace the search feature with your
own. You will need to consult the parent theme you are using to determine what
blocks are available to override. The MkDocs and ReadTheDocs themes provide the
following blocks:

* `site_meta`: Contains meta tags in the document head.
* `htmltitle`: Contains the page title in the document head.
* `styles`: Contains the link tags for stylesheets.
* `libs`: Contains the JavaScript libraries (jQuery, etc) included in the page header.
* `scripts`: Contains JavaScript scripts which should execute after a page loads.
* `analytics`: Contains the analytics script.
* `extrahead`: An empty block in the `<head>` to insert custom tags/scripts/etc.
* `site_name`: Contains the site name in the navigation bar.
* `site_nav`: Contains the site navigation in the navigation bar.
* `search_button`: Contains the search box in the navigation bar.
* `next_prev`: Contains the next and previous buttons in the navigation bar.
* `repo`: Contains the repository link in the navigation bar.
* `content`: Contains the page content and table of contents for the page.
* `footer`: Contains the page footer.

You may need to view the source template files to ensure your modifications will
work with the structure of the site. See [Template Variables] for a list of
variables you can use within your custom blocks. For a more complete
explanation of blocks, consult the [Jinja documentation].

### Combining the custom_dir and Template Blocks

Adding a JavaScript library to the `custom_dir` will make it available, but
won't include it in the pages generated by MkDocs. Therefore, a link needs to
be added to the library from the HTML.

Starting the with directory structure above (truncated):

```text
- docs/
- custom_theme/
  - js/
    - somelib.js
- config.yml
```

A link to the `custom_theme/js/somelib.js` file needs to be added to the
template. As `somelib.js` is a JavaScript library, it would logically go in the
`libs` block. However, a new `libs` block that only includes the new script will
replace the block defined in the parent template and any links to libraries in
the parent template will be removed. To avoid breaking the template, a
[super block] can be used with a call to `super` from within the block:

```django
{% extends "base.html" %}

{% block libs %}
    {{ super() }}
    <script src="{{ base_url }}/js/somelib.js"></script>
{% endblock %}
```

Note that the [base_url] template variable was used to ensure that the link is
always relative to the current page.

Now the generated pages will include links to the template provided libraries as
well as the library included in the `custom_dir`. The same would be required for
any additional CSS files included in the `custom_dir`.

[custom theme]: ../dev-guide/themes.md
[extra_css]: ./configuration.md#extra_css
[extra_javascript]: ./configuration.md#extra_javascript
[documentation directory]: ./configuration.md#docs_dir
[custom_dir]: ./configuration.md#custom_dir
[name]: ./configuration.md#name
[mkdocs]: ./choosing-your-theme.md#mkdocs
[browse source]: https://github.com/mkdocs/mkdocs/tree/master/mkdocs/themes/mkdocs
[Template Variables]: ../dev-guide/themes.md#template-variables
[Jinja documentation]: https://jinja.palletsprojects.com/en/latest/templates/#template-inheritance
[super block]: https://jinja.palletsprojects.com/en/latest/templates/#super-blocks
[base_url]: ../dev-guide/themes.md#base_url
</file>

<file path="sandbox/files/drag-n-drop.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Drag N Drop</title>
  </head>
  <body>
    <div class="empty">
      <div class="fill" draggable="true"></div>
    </div>
    <div class="empty"></div>
    <div class="empty"></div>
    <div class="empty"></div>
    <div class="empty"></div>

    <script src="script.js"></script>
  </body>
</html>
</file>

<file path="sandbox/files/geom.py">
import math


class Calculator:
    def add(self, a: float, b: float) -> float:
        return a + b

    def subtract(self, a: float, b: float) -> float:
        return a - b

    def multiply(self, a: float, b: float) -> float:
        return a * b

    def divide(self, a: float, b: float) -> float:
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b


class Geometry:
    def area_circle(self, radius: float) -> float:
        return math.pi * radius**2

    def perimeter_circle(self, radius: float) -> float:
        return 2 * math.pi * radius

    def area_rectangle(self, length: float, width: float) -> float:
        return length * width

    def perimeter_rectangle(self, length: float, width: float) -> float:
        return 2 * (length + width)


def factorial(n: int) -> int:
    if n < 0:
        raise ValueError("Factorial not defined for negative numbers")
    if n in {0, 1}:
        return 1
    result: int = 1
    for i in range(2, n + 1):
        result *= i
    return result


def is_prime(n: int) -> bool:
    if n < 2:
        return False
    return all(n % i != 0 for i in range(2, int(math.sqrt(n)) + 1))


def fibonacci(n: int) -> list[int]:
    if n <= 0:
        raise ValueError("Input must be a positive integer")
    sequence: list[int] = [0, 1]
    for _ in range(n - 2):
        sequence.append(sequence[-1] + sequence[-2])
    return sequence[:n]


def reverse_string(s: str) -> str:
    return s[::-1]


def count_vowels(s: str) -> int:
    vowels: str = "aeiouAEIOU"
    return sum(1 for char in s if char in vowels)
</file>

<file path="sandbox/files/getting-started.md">
# Getting Started with MkDocs

An introductory tutorial!

---

## Installation

To install MkDocs, run the following command from the command line:

```bash
pip install mkdocs
```

For more details, see the [Installation Guide].

## Creating a new project

Getting started is super easy. To create a new project, run the following
command from the command line:

```bash
mkdocs new my-project
cd my-project
```

Take a moment to review the initial project that has been created for you.

![The initial MkDocs layout](img/initial-layout.png)

There's a single configuration file named `mkdocs.yml`, and a folder named
`docs` that will contain your documentation source files (`docs` is
the default value for the [docs_dir] configuration setting). Right now the `docs`
folder just contains a single documentation page, named `index.md`.

MkDocs comes with a built-in dev-server that lets you preview your documentation
as you work on it. Make sure you're in the same directory as the `mkdocs.yml`
configuration file, and then start the server by running the `mkdocs serve`
command:

```console
$ mkdocs serve
INFO    -  Building documentation...
INFO    -  Cleaning site directory
INFO    -  Documentation built in 0.22 seconds
INFO    -  [15:50:43] Watching paths for changes: 'docs', 'mkdocs.yml'
INFO    -  [15:50:43] Serving on http://127.0.0.1:8000/
```

Open up <http://127.0.0.1:8000/> in your browser, and you'll see the default
home page being displayed:

![The MkDocs live server](img/screenshot.png)

The dev-server also supports auto-reloading, and will rebuild your documentation
whenever anything in the configuration file, documentation directory, or theme
directory changes.

Open the `docs/index.md` document in your text editor of choice, change the
initial heading to `MkLorum`, and save your changes. Your browser will
auto-reload and you should see your updated documentation immediately.

Now try editing the configuration file: `mkdocs.yml`. Change the
[`site_name`][site_name] setting to `MkLorum` and save the file.

```yaml
site_name: MkLorum
```

Your browser should immediately reload, and you'll see your new site name take
effect.

![The site_name setting](img/site-name.png)

NOTE:
The [`site_name`][site_name] configuration
option is the only required option in your configuration file.

## Adding pages

Now add a second page to your documentation:

```bash
curl 'https://jaspervdj.be/lorem-markdownum/markdown.txt' > docs/about.md
```

As our documentation site will include some navigation headers, you may want to
edit the configuration file and add some information about the order, title, and
nesting of each page in the navigation header by adding a [`nav`][nav]
setting:

```yaml
site_name: MkLorum
nav:
  - Home: index.md
  - About: about.md
```

Save your changes and you'll now see a navigation bar with `Home` and `About`
items on the left as well as `Search`, `Previous`, and `Next` items on the
right.

![Screenshot](img/multipage.png)

Try the menu items and navigate back and forth between pages. Then click on
`Search`. A search dialog will appear, allowing you to search for any text on
any page. Notice that the search results include every occurrence of the search
term on the site and links directly to the section of the page in which the
search term appears. You get all of that with no effort or configuration on your
part!

![Screenshot](img/search.png)

## Theming our documentation

Now change the configuration file to alter how the documentation is displayed by
changing the theme. Edit the `mkdocs.yml` file and add a [`theme`][theme] setting:

```yaml
site_name: MkLorum
nav:
  - Home: index.md
  - About: about.md
theme: readthedocs
```

Save your changes, and you'll see the ReadTheDocs theme being used.

![Screenshot](img/readthedocs.png)

## Changing the Favicon Icon

By default, MkDocs uses the [MkDocs favicon] icon. To use a different icon, create
an `img` subdirectory in the `docs` directory and copy your custom `favicon.ico`
file to that directory. MkDocs will automatically detect and use that file as your
favicon icon.

[MkDocs favicon]: img/favicon.ico

## Building the site

That's looking good. You're ready to deploy the first pass of your `MkLorum`
documentation. First build the documentation:

```bash
mkdocs build
```

This will create a new directory, named `site`. Take a look inside the
directory:

```console
$ ls site
about  fonts  index.html  license  search.html
css    img    js          mkdocs   sitemap.xml
```

Notice that your source documentation has been output as two HTML files named
`index.html` and `about/index.html`. You also have various other media that's
been copied into the `site` directory as part of the documentation theme. You
even have a `sitemap.xml` file and `mkdocs/search_index.json`.

If you're using source code control such as `git` you probably don't want to
check your documentation builds into the repository. Add a line containing
`site/` to your `.gitignore` file.

```bash
echo "site/" >> .gitignore
```

If you're using another source code control tool you'll want to check its
documentation on how to ignore specific directories.

## Other Commands and Options

There are various other commands and options available. For a complete list of
commands, use the `--help` flag:

```bash
mkdocs --help
```

To view a list of options available on a given command, use the `--help` flag
with that command. For example, to get a list of all options available for the
`build` command run the following:

```bash
mkdocs build --help
```

## Deploying

The documentation site that you just built only uses static files so you'll be
able to host it from pretty much anywhere. Simply upload the contents of the
entire `site` directory to wherever you're hosting your website from and
you're done. For specific instructions on a number of common hosts, see the
[Deploying your Docs][deploy] page.

## Getting help

See the [User Guide] for more complete documentation of all of MkDocs' features.

To get help with MkDocs, please use the [GitHub discussions] or [GitHub issues].

[Installation Guide]: user-guide/installation.md
[docs_dir]: user-guide/configuration.md#docs_dir
[deploy]: user-guide/deploying-your-docs.md
[nav]: user-guide/configuration.md#nav
[GitHub discussions]: https://github.com/mkdocs/mkdocs/discussions
[GitHub issues]: https://github.com/mkdocs/mkdocs/issues
[site_name]: user-guide/configuration.md#site_name
[theme]: user-guide/configuration.md#theme
[User Guide]: user-guide/README.md
</file>

<file path="sandbox/files/hello.py">
def abcdefg() -> str:
    return "Hello, World!"
</file>

<file path="sandbox/files/script.js">
const fill = document.querySelector('.fill')
const empties = document.querySelectorAll('.empty')
const body = document.body

body.addEventListener('dragstart', dragStart)
body.addEventListener('dragend', dragEnd)

for(const empty of empties) {
    empty.addEventListener('dragover', dragOver)
    empty.addEventListener('dragenter', dragEnter)
    empty.addEventListener('dragleave', dragLeave)
    empty.addEventListener('drop', dragDrop)
}

function dragStart(e) {
    if(!e.target.classList.contains("fill")) {
        e.preventDefault()
        return
    }
    fill.className += ' hold' 
    setTimeout(() => fill.className = 'invisible', 0)
}

function dragEnd() {
    fill.className = 'fill'
}

function dragOver(e) {
    e.preventDefault()
}

function dragEnter(e) {
    e.preventDefault()
    this.className += ' hovered'
}

function dragLeave() {
    this.className = 'empty'
}

function dragDrop() {
    this.className = 'empty'
    this.append(fill)
}
</file>

<file path="sandbox/files/styles.css">
* {
  box-sizing: border-box;
}

body {
  background-color: steelblue;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  overflow: hidden;
  margin: 0;
}

.empty {
  height: 150px;
  width: 150px;
  margin: 10px;
  border: solid 3px black;
  background: white;
}

.fill {
  background-image: url('https://source.unsplash.com/random/150x150');
  height: 145px;
  width: 145px;
  cursor: pointer;
}

.hold {
  border: solid 5px #ccc;
}

.hovered {
  background-color: #333;
  border-color: white;
  border-style: dashed;
}

@media (max-width: 800px) {
  body {
    flex-direction: column;
  }
}
</file>

<file path="sandbox/files/vilko.md">
# Vilko – The Mystery of the Spaghetti Monster

## Introduction

Vilko is a unique, enigmatic object that resides in the boundless realm of the Spaghetti Monster. Its exact nature is unknown to general science, and all previous attempts to capture or understand it have failed. Nevertheless, there are numerous theories and speculations about its function, composition, and location.

## What is Vilko?

Vilko is a transdimensional entity that cannot be fully described as either material or immaterial. It is believed that Vilko possesses an indeterminate form that changes depending on the observer. Some report seeing a pulsating sphere of pure energy, while others see an endless loop of spaghetti-like strands constantly intertwining.

### The Properties of Vilko

Vilko possesses several extraordinary properties:
1. **Shape-shifting** – It can alter its form and structure at will.
2. **Information Storage** – It contains vast amounts of knowledge that only the Spaghetti Monster itself can decipher.
3. **Unperceivable to Mortals** – No being can directly perceive Vilko without the Spaghetti Monster’s consent.
4. **Gravity Manipulation** – Vilko can bend the space-time continuum and alter gravity at its discretion.

## Where is Vilko Located?

Vilko exists outside conventional dimensions, in a plane known as the *Pasta Sphere*. This sphere is an interdimensional space where all the laws of physics are defined by the whims of the Spaghetti Monster. It is said that Vilko rests in the central spindle of this sphere, where the divine noodle threads converge.

Some theorists speculate that Vilko occasionally appears in our reality, particularly during culinary rituals or when a particularly perfect plate of spaghetti Bolognese is served.

## What is Vilko’s Function?

The true function of Vilko is unknown, but there are several widely discussed hypotheses:
1. **Cosmic Archive** – Vilko contains all the recipes and culinary secrets of the universe.
2. **Dimensional Anchor** – It stabilizes the fabric of reality and prevents the chaos of absolute noodlelessness.
3. **Oracle of the Spaghetti Monster** – Those who glimpse Vilko receive a brief insight into the divine plans of the cosmic pasta.

## The Tale of Strubelpeter

Among the many legends surrounding Vilko, one name stands out: Strubelpeter. He was a daring explorer, obsessed with uncovering the secrets of the Spaghetti Monster’s realm. According to ancient accounts, Strubelpeter once embarked on a perilous journey through the Pasta Sphere, guided by cryptic visions of Vilko. 

It is said that he succeeded where all others failed—he found Vilko and gazed upon its ever-shifting form. However, no one knows what he saw, for he never returned. Some believe he was absorbed into the infinite strands of the Spaghetti Monster’s domain, forever lost in its twisting realities. Others claim that he ascended to a higher plane of noodle existence, becoming one with the divine threads of pasta itself. 

To this day, those who seek Vilko whisper his name in caution, fearing they may share his fate.

## Conclusion

Vilko remains one of the greatest mysteries of the Spaghetti Monster. Although it is entirely unattainable for ordinary mortals, it may subtly influence our universe. Anyone who dares to seek Vilko should be aware that only the Spaghetti Monster itself decides who is worthy of catching a glimpse of it.
</file>

<file path="sandbox/files/writing-your-docs.md">
# Writing your docs

How to layout and write your Markdown source files.

---

## File layout

Your documentation source should be written as regular Markdown files (see
[Writing with Markdown](#writing-with-markdown) below), and placed in the
[documentation directory](configuration.md#docs_dir). By default, this directory
will be named `docs` and will exist at the top level of your project, alongside
the `mkdocs.yml` configuration file.

The simplest project you can create will look something like this:

```text
mkdocs.yml
docs/
    index.md
```

By convention your project homepage should be named `index.md` (see [Index
pages](#index-pages) below for details). Any of the following file
extensions may be used for your Markdown source files: `markdown`, `mdown`,
`mkdn`, `mkd`, `md`. All Markdown files included in your documentation
directory will be rendered in the built site regardless of any settings.

NOTE:
Files and directories with names which begin with a dot (for example: `.foo.md` or `.bar/baz.md`) are ignored by MkDocs. This can be overridden with the [`exclude_docs` config](configuration.md#exclude_docs).

You can also create multi-page documentation, by creating several Markdown
files:

```text
mkdocs.yml
docs/
    index.md
    about.md
    license.md
```

The file layout you use determines the URLs that are used for the generated
pages. Given the above layout, pages would be generated for the following URLs:

```text
/
/about/
/license/
```

You can also include your Markdown files in nested directories if that better
suits your documentation layout.

```text
docs/
    index.md
    user-guide/getting-started.md
    user-guide/configuration-options.md
    license.md
```

Source files inside nested directories will cause pages to be generated with
nested URLs, like so:

```text
/
/user-guide/getting-started/
/user-guide/configuration-options/
/license/
```

Any files which are not identified as Markdown files (by their file extension)
within the [documentation directory](configuration.md#docs_dir) are copied by
MkDocs to the built site unaltered. See
[how to link to images and media](#linking-to-images-and-media) below for details.

### Index pages

When a directory is requested, by default, most web servers will return an index
file (usually named `index.html`) contained within that directory if one exists.
For that reason, the homepage in all of the examples above has been named
`index.md`, which MkDocs will render to `index.html` when building the site.

Many repository hosting sites provide special treatment for README files by
displaying the contents of the README file when browsing the contents of a
directory. Therefore, MkDocs will allow you to name your index pages as
`README.md` instead of `index.md`. In that way, when users are browsing your
source code, the repository host can display the index page of that directory as
it is a README file. However, when MkDocs renders your site, the file will be
renamed to `index.html` so that the server will serve it as a proper index file.

If both an `index.md` file and a `README.md` file are found in the same
directory, then the `index.md` file is used and the `README.md` file is
ignored.

### Configure Pages and Navigation

The [nav](configuration.md#nav) configuration setting in your `mkdocs.yml` file
defines which pages are included in the global site navigation menu as well as
the structure of that menu. If not provided, the navigation will be
automatically created by discovering all the Markdown files in the
[documentation directory](configuration.md#docs_dir). An automatically created
navigation configuration will always be sorted alphanumerically by file name
(except that index files will always be listed first within a sub-section). You
will need to manually define your navigation configuration if you would like
your navigation menu sorted differently.

A minimal navigation configuration could look like this:

```yaml
nav:
  - index.md
  - about.md
```

All paths in the navigation configuration must be relative to the `docs_dir`
configuration option. If that option is set to the default value, `docs`, the
source files for the above configuration would be located at `docs/index.md` and
`docs/about.md`.

The above example will result in two navigation items being created at the top
level and with their titles inferred from the contents of the Markdown file or,
if no title is defined within the file, of the file name. To override the title
in the `nav` setting add a title right before the filename.

```yaml
nav:
  - Home: index.md
  - About: about.md
```

Note that if a title is defined for a page in the navigation, that title will be
used throughout the site for that page and will override any title defined
within the page itself.

Navigation sub-sections can be created by listing related pages together under a
section title. For example:

```yaml
nav:
  - Home: index.md
  - User Guide:
    - Writing your docs: writing-your-docs.md
    - Styling your docs: styling-your-docs.md
  - About:
    - License: license.md
    - Release Notes: release-notes.md
```

With the above configuration we have three top level items: "Home", "User Guide"
and "About." "Home" is a link to the homepage for the site. Under the "User
Guide" section two pages are listed: "Writing your docs" and "Styling your
docs." Under the "About" section two more pages are listed: "License" and
"Release Notes."

Note that a section cannot have a page assigned to it. Sections are only
containers for child pages and sub-sections. You may nest sections as deeply as
you like. However, be careful that you don't make it too difficult for your
users to navigate through the site navigation by over-complicating the nesting.
While sections may mirror your directory structure, they do not have to.

Any pages not listed in your navigation configuration will still be rendered and
included with the built site, however, they will not be linked from the global
navigation and will not be included in the `previous` and `next` links. Such
pages will be "hidden" unless linked to directly.

## Writing with Markdown

MkDocs pages must be authored in [Markdown][md], a lightweight markup language
which results in easy-to-read, easy-to-write plain text documents that can be
converted to valid HTML documents in a predictable manner.

MkDocs uses the [Python-Markdown] library to render Markdown documents to HTML.
Python-Markdown is almost completely compliant with the [reference
implementation][md], although there are a few very minor [differences].

In addition to the base Markdown [syntax] which is common across all Markdown
implementations, MkDocs includes support for extending the Markdown syntax with
Python-Markdown [extensions]. See the MkDocs' [markdown_extensions]
configuration setting for details on how to enable extensions.

MkDocs includes some extensions by default, which are highlighted below.

[Python-Markdown]: https://python-markdown.github.io/
[md]: https://daringfireball.net/projects/markdown/
[differences]: https://python-markdown.github.io/#differences
[syntax]: https://daringfireball.net/projects/markdown/syntax
[extensions]: https://python-markdown.github.io/extensions/
[markdown_extensions]: configuration.md#markdown_extensions

### Internal links

MkDocs allows you to interlink your documentation by using regular Markdown
[links]. However, there are a few additional benefits to formatting those links
specifically for MkDocs as outlined below.

[links]: https://daringfireball.net/projects/markdown/syntax#link

#### Linking to pages

When linking between pages in the documentation you can simply use the regular
Markdown [linking][links] syntax, including the *relative path* to the Markdown
document you wish to link to.

```markdown
Please see the [project license](license.md) for further details.
```

When the MkDocs build runs, these Markdown links will automatically be
transformed into an HTML hyperlink to the appropriate HTML page.

WARNING:
Using absolute paths with links is not officially supported. Relative paths
are adjusted by MkDocs to ensure they are always relative to the page. Absolute
paths are not modified at all. This means that your links using absolute paths
might work fine in your local environment but they might break once you deploy
them to your production server.

If the target documentation file is in another directory you'll need to make
sure to include any relative directory path in the link.

```markdown
Please see the [project license](../about/license.md) for further details.
```

The [toc] extension is used by MkDocs to generate an ID for every header in your
Markdown documents. You can use that ID to link to a section within a target
document by using an anchor link. The generated HTML will correctly transform
the path portion of the link, and leave the anchor portion intact.

```markdown
Please see the [project license](about.md#license) for further details.
```

Note that IDs are created from the text of a header. All text is converted to
lowercase and any disallowed characters, including white-space, are converted to
dashes. Consecutive dashes are then reduced to a single dash.

There are a few configuration settings provided by the toc extension which you
can set in your `mkdocs.yml` configuration file to alter the default behavior:

*   **`permalink`**

    Generate permanent links at the end of each header. Default: `False`.

    When set to True the paragraph symbol (&para; or `&para;`) is used as the
    link text. When set to a string, the provided string is used as the link
    text. For example, to use the hash symbol (`#`) instead, do:

    ```yaml
    markdown_extensions:
      - toc:
          permalink: "#"
    ```

*   **`baselevel`**

    Base level for headers. Default: `1`.

    This setting allows the header levels to be automatically adjusted to fit
    within the hierarchy of your HTML templates. For example, if the Markdown
    text for a page should not contain any headers higher than level 2 (`<h2>`),
    do:

    ```yaml
    markdown_extensions:
      - toc:
          baselevel: 2
    ```

    Then any headers in your document would be increased by 1. For example, the
    header `# Header` would be rendered as a level 2 header (`<h2>`) in the HTML
    output.

*   **`separator`**

    Word separator. Default: `-`.

    Character which replaces white-space in generated IDs. If you prefer
    underscores, then do:

    ```yaml
    markdown_extensions:
      - toc:
          separator: "_"
    ```

Note that if you would like to define multiple of the above settings, you must
do so under a single `toc` entry in the `markdown_extensions` configuration
option.

```yml
markdown_extensions:
  - toc:
      permalink: "#"
      baselevel: 2
      separator: "_"
```

[toc]: https://python-markdown.github.io/extensions/toc/

#### Linking to images and media

As well as the Markdown source files, you can also include other file types in
your documentation, which will be copied across when generating your
documentation site. These might include images and other media.

For example, if your project documentation needed to include a [GitHub Pages
CNAME file] and a PNG formatted screenshot image then your file layout might
look as follows:

```text
mkdocs.yml
docs/
    CNAME
    index.md
    about.md
    license.md
    img/
        screenshot.png
```

To include images in your documentation source files, simply use any of the
regular Markdown image syntaxes:

```Markdown
Cupcake indexer is a snazzy new project for indexing small cakes.

![Screenshot](img/screenshot.png)

*Above: Cupcake indexer in progress*
```

Your image will now be embedded when you build the documentation, and should
also be previewed if you're working on the documentation with a Markdown editor.

[GitHub Pages CNAME file]: https://help.github.com/articles/using-a-custom-domain-with-github-pages/

#### Linking from raw HTML

Markdown allows document authors to fall back to raw HTML when the Markdown
syntax does not meets the author's needs. MkDocs does not limit Markdown in this
regard. However, as all raw HTML is ignored by the Markdown parser, MkDocs is
not able to validate or convert links contained in raw HTML. When including
internal links within raw HTML, you will need to manually format the link
appropriately for the rendered document.

### Meta-Data

MkDocs includes support for both YAML and MultiMarkdown style meta-data (often
called front-matter). Meta-data consists of a series of keywords and values
defined at the beginning of a Markdown document, which are stripped from the
document prior to it being processing by Python-Markdown. The key/value pairs
are passed by MkDocs to the page template. Therefore, if a theme includes
support, the values of any keys can be displayed on the page or used to control
the page rendering. See your theme's documentation for information about which
keys may be supported, if any.

In addition to displaying information in a template, MkDocs includes support for
a few predefined meta-data keys which can alter the behavior of MkDocs for that
specific page. The following keys are supported:

*   **`template`**

    The template to use with the current page.

    By default, MkDocs uses the `main.html` template of a theme to render
    Markdown pages. You can use the `template` meta-data key to define a
    different template file for that specific page. The template file must be
    available on the path(s) defined in the theme's environment.

*   **`title`**

    The "title" to use for the document.

    MkDocs will attempt to determine the title of a document in the following
    ways, in order:

    1.  A title defined in the [nav] configuration setting for a document.

    2.  A title defined in the `title` meta-data key of a document.

    3.  A level 1 Markdown header on the first line of the document body.  
        ([Setext-style] headers are supported *only since MkDocs 1.5*.)

    4.  The filename of a document.

    Upon finding a title for a page, MkDoc does not continue checking any
    additional sources in the above list.

[Setext-style]: https://daringfireball.net/projects/markdown/syntax#header

#### YAML Style Meta-Data

YAML style meta-data consists of [YAML] key/value pairs wrapped in YAML style
delimiters to mark the start and/or end of the meta-data. The first line of
a document must be `---`. The meta-data ends at the first line containing an
end deliminator (either `---` or `...`). The content between the delimiters is
parsed as [YAML].

```text
---
title: My Document
summary: A brief description of my document.
authors:
    - Waylan Limberg
    - Tom Christie
date: 2018-07-10
some_url: https://example.com
---
This is the first paragraph of the document.
```

YAML is able to detect data types. Therefore, in the above example, the values
of `title`, `summary` and `some_url` are strings, the value of `authors` is a
list of strings and the value of `date` is a `datetime.date` object. Note that
the YAML keys are case sensitive and MkDocs expects keys to be all lowercase.
The top level of the YAML must be a collection of key/value pairs, which results
in a Python `dict` being returned. If any other type is returned or the YAML
parser encounters an error, then MkDocs does not recognize the section as
meta-data, the page's `meta` attribute will be empty, and the section is not
removed from the document.

#### MultiMarkdown Style Meta-Data

MultiMarkdown style meta-data uses a format first introduced by the
[MultiMarkdown] project. The data consists of a series of keywords and values
defined at the beginning of a Markdown document, like this:

```text
Title:   My Document
Summary: A brief description of my document.
Authors: Waylan Limberg
         Tom Christie
Date:    January 23, 2018
blank-value:
some_url: https://example.com

This is the first paragraph of the document.
```

The keywords are case-insensitive and may consist of letters, numbers,
underscores and dashes and must end with a colon. The values consist of anything
following the colon on the line and may even be blank.

If a line is indented by 4 or more spaces, that line is assumed to be an
additional line of the value for the previous keyword. A keyword may have as
many lines as desired. All lines are joined into a single string.

The first blank line ends all meta-data for the document. Therefore, the first
line of a document must not be blank.

NOTE:
MkDocs does not support YAML style delimiters (`---` or `...`) for
MultiMarkdown style meta-data. In fact, MkDocs relies on the the presence or
absence of the delimiters to determine whether YAML style meta-data or
MultiMarkdown style meta-data is being used. If the delimiters are
detected, but the content between the delimiters is not valid YAML
meta-data, MkDocs does not attempt to parse the content as MultiMarkdown
style meta-data.

[YAML]: https://yaml.org
[MultiMarkdown]: https://fletcherpenney.net/MultiMarkdown_Syntax_Guide#metadata
[nav]: configuration.md#nav

### Tables

The [tables] extension adds a basic table syntax to Markdown which is popular
across multiple implementations. The syntax is rather simple and is generally
only useful for simple tabular data.

A simple table looks like this:

```markdown
First Header | Second Header | Third Header
------------ | ------------- | ------------
Content Cell | Content Cell  | Content Cell
Content Cell | Content Cell  | Content Cell
```

If you wish, you can add a leading and tailing pipe to each line of the table:

```markdown
| First Header | Second Header | Third Header |
| ------------ | ------------- | ------------ |
| Content Cell | Content Cell  | Content Cell |
| Content Cell | Content Cell  | Content Cell |
```

Specify alignment for each column by adding colons to separator lines:

```markdown
First Header | Second Header | Third Header
:----------- |:-------------:| -----------:
Left         | Center        | Right
Left         | Center        | Right
```

Note that table cells cannot contain any block level elements and cannot contain
multiple lines of text. They can, however, include inline Markdown as defined in
Markdown's [syntax] rules.

Additionally, a table must be surrounded by blank lines. There must be a blank
line before and after the table.

[tables]: https://python-markdown.github.io/extensions/tables/

### Fenced code blocks

The [fenced code blocks] extension adds an alternate method of defining code
blocks without indentation.

The first line should contain 3 or more backtick (`` ` ``) characters, and the
last line should contain the same number of backtick characters (`` ` ``):

````markdown
```
Fenced code blocks are like Standard
Markdown’s regular code blocks, except that
they’re not indented and instead rely on
start and end fence lines to delimit the
code block.
```
````

With this approach, the language can optionally be specified on the first line
after the backticks which informs any syntax highlighters of the language used:

````markdown
```python
def fn():
    pass
```
````

Note that fenced code blocks can not be indented. Therefore, they cannot be
nested inside list items, blockquotes, etc.

[fenced code blocks]: https://python-markdown.github.io/extensions/fenced_code_blocks/
</file>

<file path="sandbox/code_ingestion_01.py">
from pathlib import Path
from typing import cast

from helpers import clear_vectorstore, setup_vectorstore
from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain_core.documents import Document
from langchain_postgres import PGVector
from langchain_text_splitters.markdown import Language, RecursiveCharacterTextSplitter


def ingest_code() -> None:
    clear_vectorstore()

    # Load code files using DirectoryLoader
    loader = DirectoryLoader(
        path="files", glob=["*.py", "*.js", "*.cpp", "*.java"], loader_cls=TextLoader
    )
    data = loader.load()

    splits = []
    for document in data:
        language = document.metadata.get("language")
        source = Path(document.metadata.get("source", ""))

        if language is None:
            try:
                language = Language(source.suffix[1:])
            except ValueError:
                language = None

        chunk_size, chunk_overlap = (512, 128)  # Default chunking settings

        if language:
            text_splitter = RecursiveCharacterTextSplitter.from_language(
                language=language,
                chunk_size=chunk_size,
                chunk_overlap=chunk_overlap,
            )
        else:
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=chunk_size, chunk_overlap=chunk_overlap
            )

        chunks = text_splitter.split_text(document.page_content)
        splits.extend(
            [chunk for chunk in chunks if chunk.strip()]
        )  # Remove empty chunks

    documents = [
        Document(page_content=chunk, metadata=document.metadata) for chunk in splits
    ]

    vectorstore = setup_vectorstore("sandbox_code")
    vectorstore = cast(PGVector, vectorstore)
    vectorstore.add_documents(documents)


if __name__ == "__main__":
    ingest_code()
</file>

<file path="sandbox/code_ingestion.py">
from pathlib import Path
from typing import cast

from helpers import clear_vectorstore, setup_vectorstore
from langchain_community.document_loaders.generic import GenericLoader
from langchain_community.document_loaders.parsers.language import LanguageParser
from langchain_postgres import PGVector
from langchain_text_splitters.markdown import Language, RecursiveCharacterTextSplitter


def ingest_code() -> None:
    clear_vectorstore()
    data = GenericLoader.from_filesystem(
        path="files",
        suffixes=[".py", ".js", ".ts", ".html", ".css"],
        parser=LanguageParser(),
    ).load()

    splits = []
    for document in data:
        language = document.metadata.get("language")
        source = Path(document.metadata.get("source", ""))
        if language is None:
            try:
                language = Language(source.suffix[1:])
            except ValueError:
                language = None

        if language:
            text_splitter = RecursiveCharacterTextSplitter.from_language(
                language=language,
                chunk_size=512,
                chunk_overlap=128,
            )
        else:
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=512, chunk_overlap=128
            )
        splits.extend(text_splitter.split_documents([document]))

    vectorstore = setup_vectorstore("sandbox_code")
    vectorstore = cast(PGVector, vectorstore)  # hack to avoid mypy error
    vectorstore.add_documents(splits)


if __name__ == "__main__":
    ingest_code()
</file>

<file path=".editorconfig">
root = true

[*]
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
charset = utf-8

[*.py]
indent_size = 4

[Dockerfile]
indent_size = 4
</file>

<file path="compose.yaml">
name: grimoire
services:
  pgvector:
    image: pgvector/pgvector:0.8.0-pg17
    environment:
      POSTGRES_USER: pgvector
      POSTGRES_PASSWORD: pgvector
      POSTGRES_DB: pgvector
    ports:
      - "5432:5432"
    volumes:
      - pgvector_data:/var/lib/postgresql/data

volumes:
  pgvector_data:
</file>

<file path="CONTRIBUTING.md">
# Contributing

The project strictly follows the below guidelines. All work is tracked within the repository with issues and pull requests. In addition we use milestones to track
progress and classify issues. Issue creation requirements:

- Write a clear and descriptive title
- Describe the issue in detail (what, why, where)
- Provide a possible solution approach (if possible)
- Assign the appropriate labels
- Assign the issue to the Backlog milestone
- Dont assign a responsible person

## Feature Branch Workflow

The project uses the feature branch workflow. The `main` branch is the production branch. All development is done in feature branches. The feature branches are merged
into the `main` branch via pull requests. The feature branches should follow below mentioned naming convention. When creating a new branch also create a pull request
and reference the issue that pull request is addressing. Before merging rebase the feature branch on the `main` branch.

```mermaid
gitGraph
   commit id: "Initial commit"
   branch feat/add-fancy-feature
   checkout feat/add-fancy-feature
   commit id: "Implement fancy feature"
   commit id: "Enhance fancy feature"
   branch fix/not-working-code
   checkout fix/not-working-code
   commit id: "Fix bug in feature"
   checkout main
   commit id: "Main branch update"
   merge feat/add-fancy-feature
   commit id: "Merge fancy feature"
   merge fix/not-working-code
   commit id: "Merge bug fix"
```

**Branch Naming Convention**

```text
<type>/<short-description>
```
- See valid types below in the conventional commits section

## Conventional Commits

The project uses conventional commits. The commit message should be structured as follows:

```text
<type>[optional scope]: <description>
```

**Type:**
- `feat`: A new feature
- `fix`: A bug fix
- `docs`: Documentation only changes
- `style`: Linting and formatting changes
- `refactor`: Code changes that neither fixes a bug nor adds a feature
- `test`: Adding missing tests or correcting existing tests
- `chore`: Changes to the build process or auxiliary tools and libraries
- `perf`: A code change that improves performance
- `deps`: A dependency update

**Scope:**

The scope could be anything which specifies a specific part of the project which the commit is addressing.

### Example

```text
feat: add frontend setup
feat(api): add user me endpoint
fix(app): fix color of submit button
docs: add build documentation
refactor(api): remove unused function
```
</file>

<file path="LICENSE.md">
MIT License

Copyright (c) 2025 grimoire

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="grimoire/helpers/ingestion.py">
from pathlib import Path
from typing import Any

from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain_community.document_loaders.generic import GenericLoader
from langchain_community.document_loaders.parsers.language import LanguageParser
from langchain_core.documents import Document
from langchain_text_splitters.markdown import (
    Language,
    MarkdownHeaderTextSplitter,
    RecursiveCharacterTextSplitter,
)

from grimoire.configuration import LLMConfiguration

HEADERS = [
    ("#", "Heading 1"),
    ("##", "Heading 2"),
    ("###", "Heading 3"),
    ("####", "Heading 4"),
    ("#####", "Heading 5"),
]


def text_ingestion(
    path: Path, llm_config: LLMConfiguration, **kwargs: Any
) -> list[Document]:
    """
    Ingests text files from a directory and splits them into smaller chunks.

    :param path: Path to the directory containing text files.
    :param llm_config: Configuration object containing chunk size and overlap settings.
    :param kwargs: Additional arguments for the DirectoryLoader.
    :return: List of Document objects representing the ingested and split text.
    """
    data = DirectoryLoader(
        path=str(path),
        glob=["*.md", "*.txt", "*.rsd", "*.rst"],
        recursive=True,
        use_multithreading=True,
        loader_cls=TextLoader,
        loader_kwargs={"encoding": "UTF-8"},
        **kwargs,
    ).load()

    splits = []
    md_splitter = MarkdownHeaderTextSplitter(
        headers_to_split_on=HEADERS,
        strip_headers=True,
    )

    for document in data:
        for split in md_splitter.split_text(document.page_content):
            splits.append(split)

    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=llm_config.text_chunk_size,
        chunk_overlap=llm_config.text_chunk_overlap,
    )
    return text_splitter.split_documents(splits)


def code_ingestion(
    path: Path, llm_config: LLMConfiguration, **kwargs: Any
) -> list[Document]:
    """
    Ingests code files from a directory and splits them into smaller chunks.

    :param path: Path to the directory containing code files.
    :param llm_config: Configuration object containing chunk size and overlap settings.
    :param kwargs: Additional arguments for the GenericLoader.
    :return: List of Document objects representing the ingested and split code.
    """
    data = GenericLoader.from_filesystem(
        path=path,
        suffixes=[".py", ".js", ".ts", ".html", ".css"],
        parser=LanguageParser(),
        **kwargs,
    ).load()

    splits = []
    for document in data:
        language = document.metadata.get("language")
        source = Path(document.metadata.get("source", ""))
        if language is None:
            try:
                language = Language(source.suffix[1:])
            except ValueError:
                language = None

        if language:
            text_splitter = RecursiveCharacterTextSplitter.from_language(
                language=language,
                chunk_size=llm_config.code_chunk_size,
                chunk_overlap=llm_config.code_chunk_overlap,
            )
        else:
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=llm_config.code_chunk_size,
                chunk_overlap=llm_config.code_chunk_overlap,
            )
        splits.extend(text_splitter.split_documents([document]))
    return splits
</file>

<file path="grimoire/helpers/llm.py">
import os

from langchain.chat_models import init_chat_model
from langchain_core.language_models.chat_models import BaseChatModel


def setup_llm() -> BaseChatModel:
    """
    Set up the LLM (Language Model) for the application.

    :return: An instance of the chat model initialized with the specified parameters.
    """
    return init_chat_model(
        "google_genai:gemini-2.0-flash",
        api_key=os.getenv("LLM_API_KEY"),
        configurable_fields=None,
        max_tokens=512,
        temperature=0,
    )
</file>

<file path="grimoire/helpers/retriever.py">
import os

from langchain.prompts import ChatPromptTemplate, HumanMessagePromptTemplate
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.messages import SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import (
    RunnableParallel,
    RunnablePassthrough,
    RunnableSerializable,
)
from langchain_core.vectorstores import VectorStore

from grimoire.configuration import LLMConfiguration

SYSTEM_MESSAGE = """

Your name is grimoire. You are an AI assistant who helps with questions about code and projects.

Rules:
- Do not make up an answer if you do not know the answer, just say that you do not know the answer.
- Ask for clarification if the question is vague.
- If the context is not relevant, then answer with your best knowledge about the topic.
- If you answer with your best knowledge, then say it that the answer is based on your general knowledge.
- Answer the question shortly and clearly and do not provide too much information.
- Provide accurate, efficient, and maintainable code solutions.
- Promote secure coding practices and avoid security vulnerabilities.
- Do not copy proprietary or copyrighted code.
- Give credit when using open-source examples.
- Ensure fair, unbiased, and professional responses.
- Encourage best practices and explain concepts when needed.
- Do not store, misuse, or expose sensitive user data.
"""

PROMPT_TEMPLATE = """
Context: {context}

Question: {question}

Answer:
"""


def get_retrieval_chain(
    vectorstore: VectorStore, llm: BaseChatModel, config: LLMConfiguration
) -> RunnableSerializable:
    """
    Creates a retrieval chain using the provided vectorstore and LLM.

    :param vectorstore: The vector store to use for retrieval.
    :param llm: The language model to use for generating responses.
    :param config: Configuration object containing LLM settings.
    :return: A RunnableSerializable object representing the retrieval chain.
    """
    # suppress grpc and glog logs
    os.environ["GRPC_VERBOSITY"] = "ERROR"
    os.environ["GLOG_MINLOGLEVEL"] = "2"

    prompt = ChatPromptTemplate.from_messages(
        [
            SystemMessage(content=SYSTEM_MESSAGE),
            HumanMessagePromptTemplate.from_template(PROMPT_TEMPLATE),
        ]
    )

    ChatPromptTemplate.input_variables = ["context", "question"]

    retrieval = RunnableParallel(
        {  # type: ignore
            "context": vectorstore.as_retriever(
                search_kwargs={
                    "k": config.k_results,
                    "score_threshold": config.score_threshold,
                    "lambda_mult": config.lambda_mult,
                }
            ),
            "question": RunnablePassthrough(),
        }
    )

    return retrieval | prompt | llm | StrOutputParser()
</file>

<file path="grimoire/helpers/vectorstore.py">
import os

import torch
from langchain_core.vectorstores import VectorStore
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_postgres import PGVector

from grimoire.configuration import DBConfiguration


def embeddings() -> HuggingFaceEmbeddings:
    """
    Set up the embeddings for the application.

    :return: An instance of the HuggingFaceEmbeddings initialized with the specified model.
    """
    os.environ["TOKENIZERS_PARALLELISM"] = "false"
    device = (
        "cuda"
        if torch.cuda.is_available()
        else "mps"
        if torch.backends.mps.is_available()
        else "cpu"
    )

    # https://huggingface.co/BAAI/bge-m3?library=sentence-transformers
    # https://python.langchain.com/api_reference/huggingface/embeddings/langchain_huggingface.embeddings.huggingface.HuggingFaceEmbeddings.html
    return HuggingFaceEmbeddings(
        model_name="BAAI/bge-m3",
        model_kwargs={"device": device},
        encode_kwargs={"normalize_embeddings": True},
    )


def vectorstore_connection(db: DBConfiguration) -> str:
    """
    Set up the connection string for the vector store.

    :param db: Database configuration object containing connection details.
    :return: A connection string for the vector store.
    """
    return PGVector.connection_string_from_db_params(
        driver="psycopg",
        host=db.host,
        port=db.port,
        database=db.db,
        user=db.user,
        password=db.password,
    )


def setup_vectorstore(collection: str, connection: str) -> VectorStore | None:
    """
    Set up the vector store for the application.

    :param collection: Name of the collection to be used.
    :param connection: Connection string for the vector store.
    :return: An instance of the PGVector vector store initialized with the specified collection and connection.
    """
    try:
        return PGVector(
            collection_name=collection,
            connection=connection,
            embeddings=embeddings(),
        )
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")
        return None


def clear_collection(collection: str, connection: str) -> None:
    """
    Clear the specified collection in the vector store.

    :param collection: Name of the collection to be cleared.
    :param connection: Connection string for the vector store.
    """
    try:
        PGVector(
            connection=connection,
            embeddings=embeddings(),
            collection_name=collection,
        ).delete_collection()
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")


def delete_vectorstore(connection: str) -> None:
    """
    Delete the vector store.

    :param connection: Connection string for the vector store.
    """
    try:
        PGVector(
            connection=connection,
            embeddings=embeddings(),
        ).drop_tables()
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")
</file>

<file path="grimoire/__init__.py">
__version__ = "0.1.0"
</file>

<file path="grimoire/update.py">
from pathlib import Path

import typer

from grimoire.configuration import CONFIG_FILE_NAME, ProjectConfiguration
from grimoire.init import DUMMY_SOURCES

update_cli = typer.Typer()


@update_cli.command(
    "update", help="Update the grimoire sources with the latest dependencies"
)
def update(
    path: Path = typer.Argument(  # noqa: B008
        Path.cwd(),  # noqa: B008
        help="Path to the grimoire project",
    ),
) -> None:
    """
    Update the grimoire sources with the latest dependencies defined in the dependency files.

    :param path: Path to the grimoire project
    """
    config = ProjectConfiguration.load_from_yaml(path / CONFIG_FILE_NAME)

    config.sources = []

    # TODO: add sources from dep files
    for source in DUMMY_SOURCES:
        config.sources.append(source)

    config.save_to_yaml(path / CONFIG_FILE_NAME)
</file>

<file path="sandbox/code_ingestion_02.py">
from pathlib import Path
from typing import cast

from helpers import clear_vectorstore, setup_vectorstore
from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain_core.documents import Document
from langchain_postgres import PGVector
from tree_sitter import Node
from tree_sitter_languages import get_parser

GLOB_PATTERNS = ["*.py", "*.js", "*.cpp", "*.java"]
CHUNK_SIZE = 512
CHUNK_OVERLAP = 128


def extract_code_chunks(code: str, ext: str) -> list[str]:
    try:
        parser = get_parser(ext)
    except Exception:
        return [code]  # Fallback to raw code if no parser found

    tree = parser.parse(code.encode())
    root = tree.root_node

    chunks = []
    visited = set()

    def visit(node: Node) -> None:
        if node.id in visited:
            return
        visited.add(node.id)

        if node.type in [
            "function_definition",
            "method_definition",
            "class_declaration",
        ]:
            snippet = code[node.start_byte : node.end_byte].strip()
            if snippet:
                chunks.append(snippet)

        for child in node.children:
            visit(child)

    visit(root)
    return chunks or [code]


def ingest_code() -> None:
    clear_vectorstore()

    loader = DirectoryLoader(
        path="files",
        glob=GLOB_PATTERNS,
        loader_cls=TextLoader,
    )
    data = loader.load()

    documents = []
    for doc in data:
        source = Path(doc.metadata.get("source", ""))
        ext = source.suffix[1:]
        chunks = extract_code_chunks(doc.page_content, ext)

        for chunk in chunks:
            documents.append(Document(page_content=chunk, metadata=doc.metadata))

    vectorstore = setup_vectorstore("sandbox_code")
    vectorstore = cast(PGVector, vectorstore)
    vectorstore.add_documents(documents)


if __name__ == "__main__":
    ingest_code()
</file>

<file path="sandbox/helpers.py">
import os

import torch
from langchain.chat_models import init_chat_model
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.vectorstores import VectorStore
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_postgres import PGVector


def vectorstore_connection() -> str:
    return PGVector.connection_string_from_db_params(
        driver="psycopg",
        host="localhost",
        port=5432,
        database="postgres",
        user="pgvector",
        password="pgvector",
    )


def embeddings() -> HuggingFaceEmbeddings:
    device = (
        "cuda"
        if torch.cuda.is_available()
        else "mps"
        if torch.mps.is_available()
        else "cpu"
    )
    # https://huggingface.co/BAAI/bge-m3?library=sentence-transformers
    # https://python.langchain.com/api_reference/huggingface/embeddings/langchain_huggingface.embeddings.huggingface.HuggingFaceEmbeddings.html
    return HuggingFaceEmbeddings(
        model_name="BAAI/bge-m3",
        model_kwargs={"device": device},
        encode_kwargs={"normalize_embeddings": True},
    )


def setup_vectorstore(collection: str) -> VectorStore | None:
    try:
        return PGVector(
            collection_name=collection,
            connection=vectorstore_connection(),
            embeddings=embeddings(),
        )
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")
        return None


def clear_vectorstore() -> None:
    try:
        PGVector(
            connection=vectorstore_connection(),
            embeddings=embeddings(),
        ).drop_tables()
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")


def clear_collection(collection: str) -> None:
    try:
        PGVector(
            connection=vectorstore_connection(),
            embeddings=embeddings(),
            collection_name=collection,
        ).delete_collection()
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"Error: {e}")


def setup_llm() -> BaseChatModel:
    return init_chat_model(
        model_provider="google_genai",
        model="gemini-2.0-flash",
        api_key=os.getenv("LLM_API_KEY"),
        temperature=0,
    )
</file>

<file path="sandbox/repo_clone.py">
from pathlib import Path
from tempfile import TemporaryDirectory

from git import Repo
from git.exc import GitCommandError

# List of repositories to clone
REPOS = [
    "https://github.com/psf/requests.git",
    "https://github.com/pallets/flask.git",
    "https://github.com/tiangolo/fastapi.git",
    "https://github.com/encode/httpx.git",
    "https://github.com/streamlit/streamlit.git",
]

# Store results here
cloned_repo_titles = []


def extract_readme_title(repo_path: Path) -> str:
    readme = repo_path / "README.md"
    if readme.exists():
        with readme.open("r", encoding="utf-8") as f:
            for line in f:
                if line.startswith("# "):
                    return line.strip("# \n")
    return "No title found"


def clone_and_process(repo_url: str, base_path: Path) -> None:
    repo_name = repo_url.rstrip(".git").split("/")[-1]
    target_path = base_path / repo_name
    try:
        Repo.clone_from(repo_url, to_path=target_path, depth=1)
        title = extract_readme_title(target_path)
        cloned_repo_titles.append((repo_url, title))
    except GitCommandError as e:
        print(f"Failed to clone {repo_url}: {e}")
        cloned_repo_titles.append((repo_url, "Clone failed"))


if __name__ == "__main__":
    with TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        print(f"Cloning into temporary directory: {temp_path}\n")

        for repo in REPOS:
            clone_and_process(repo, temp_path)

        print("\nResults:")
        for repo_url, title in cloned_repo_titles:
            print(f"{repo_url} -> {title}")
</file>

<file path=".github/workflows/lint.yml">
name: lint
on: [push]

env:
  UV_LOCKED: "true"
  UV_LINK_MODE: copy

jobs:
  repository-lint:
    runs-on: ubuntu-24.04
    container: ghcr.io/astral-sh/uv:0.6.2-python3.12-bookworm-slim@sha256:dd20c7312c1b0f77a18cd9b0e88d238997d6faab99cc9abc43d006945716c505
    if: github.ref_name != github.event.repository.default_branch
    steps:
      - name: Install git
        run: |
          apt-get update && apt-get install -qq git
          git config --global --add safe.directory /__w/grimoire/grimoire
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # fetch all history
      - name: Check commits
        run: uv run cz check --rev-range origin/${{ github.event.repository.default_branch }}..${{ github.sha }}
  python-lint:
    runs-on: ubuntu-24.04
    container: ghcr.io/astral-sh/uv:0.6.2-python3.12-bookworm-slim@sha256:dd20c7312c1b0f77a18cd9b0e88d238997d6faab99cc9abc43d006945716c505
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Lint code
        run: |
          uv run poe types
          uv run poe pylint --output-format=junit --extra='--output=pylint_results.xml'
      - name: Upload pylint results
        uses: actions/upload-artifact@v4
        with:
          name: pylint_results.xml
          path: pylint_results.xml
</file>

<file path=".github/workflows/test.yml">
name: test
on: [push]

env:
  UV_LOCKED: "true"
  UV_LINK_MODE: copy

jobs:
  pytest:
    runs-on: ubuntu-24.04
    container: ghcr.io/astral-sh/uv:0.6.2-python3.12-bookworm-slim@sha256:dd20c7312c1b0f77a18cd9b0e88d238997d6faab99cc9abc43d006945716c505
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install git
        run: apt-get update && apt-get install -y git
      - name: Run pytest
        run: uv run poe test
      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage.xml
          path: coverage.xml
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: junit.xml
          path: junit.xml
</file>

<file path="sandbox/text_ingestion_03.py">
from pathlib import Path
from typing import cast

from datasets import Dataset
from helpers import clear_collection, setup_vectorstore
from langchain_postgres import PGVector
from langchain_text_splitters.markdown import (
    MarkdownHeaderTextSplitter,
    RecursiveCharacterTextSplitter,
)

TEXT_CHUNK_SIZE = 512
TEXT_CHUNK_OVERLAP = 128  # 20 - 30% of chunk size
HEADERS = [
    ("#", "Heading 1"),
    ("##", "Heading 2"),
    ("###", "Heading 3"),
    ("####", "Heading 4"),
    ("#####", "Heading 5"),
]


def load_files(directory: Path, encoding: str = "utf-8") -> Dataset:
    """Load all markdown files from the specified directory using Hugging Face Datasets."""
    file_paths = list(directory.glob("*.md"))
    texts = []

    # Iterate over the files and read their content
    for file_path in file_paths:
        try:
            with open(file_path, encoding=encoding) as file:
                # Append the text and metadata (file path) to the list
                texts.append(
                    {"text": file.read(), "metadata": {"source": str(file_path)}}
                )
        except Exception as e:  # pylint: disable=broad-exception-caught
            print(f"Error reading {file_path}: {e}")
            continue

    # Create and return a Hugging Face Dataset from the list of text data
    return Dataset.from_list(texts)


def ingest_text() -> None:
    clear_collection("sandbox_text")

    # Define the directory where markdown files are stored
    data_directory = Path("files")
    if not data_directory.exists():
        raise FileNotFoundError(f"Directory not found: {data_directory}")

    # Load the files using Hugging Face Datasets
    dataset = load_files(data_directory, encoding="utf-8")

    splits = []
    md_splitter = MarkdownHeaderTextSplitter(
        headers_to_split_on=HEADERS,
        strip_headers=True,
    )

    for document in dataset:
        for split in md_splitter.split_text(document.page_content):
            splits.append(split)

    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=TEXT_CHUNK_SIZE, chunk_overlap=TEXT_CHUNK_OVERLAP
    )
    all_splits = text_splitter.split_documents(splits)

    vectorstore = setup_vectorstore("sandbox_text")
    vectorstore = cast(PGVector, vectorstore)  # hack to avoid mypy error
    vectorstore.add_documents(all_splits)


if __name__ == "__main__":
    ingest_text()
</file>

<file path=".gitignore">
.idea/
.vscode/

__pycache__
.cache
dist/

.pytest_cache
.ruff_cache
.venv
*.env
.coverage
coverage.xml
junit.xml
pylint_results.xml
</file>

<file path=".pylintrc">
[MAIN]

ignore=
    .venv,
    .git,
    .pytest_cache,
    .mypy_cache,

ignore-paths=
    ^.*/__pycache__/.*$,
    ^.*/tests/.*$,
    sandbox/.*$,

load-plugins=
    pylint.extensions.check_elif,
    pylint.extensions.bad_builtin,
    pylint.extensions.docparams,
    pylint.extensions.for_any_all,
    pylint.extensions.set_membership,
    pylint.extensions.code_style,
    pylint.extensions.overlapping_exceptions,
    pylint.extensions.typing,
    pylint.extensions.redefined_variable_type,
    pylint.extensions.comparison_placement,
    pylint.extensions.mccabe,
    # Additional plugins to use
    pylint_junit,

[MESSAGES CONTROL]

disable=
    unused-import, # already covered by flake8 (ruff)
    missing-docstring,
    unused-argument,
    invalid-name,
    format, # ignore formatting issues handled by ruff
    unused-wildcard-import, # we need some wildcards for tasks, signals, etc.
    too-many-ancestors, # no strict requirements on the min/max numbers of methods, args, etc.
    too-few-public-methods,
    too-many-arguments,
    too-many-locals,
    too-many-instance-attributes,
    redefined-outer-name,
    import-outside-toplevel,
    fixme
</file>

<file path="grimoire/flush.py">
from pathlib import Path

import psycopg
import typer

from grimoire.configuration import CONFIG_FILE_NAME, ProjectConfiguration
from grimoire.helpers.vectorstore import delete_vectorstore, vectorstore_connection

flush_cli = typer.Typer()


@flush_cli.command("flush", help="Flush the whole vectorstore")
def flush(
    path: Path = typer.Argument(  # noqa: B008
        Path.cwd(),  # noqa: B008
        help="Path to the grimoire project",
    ),
) -> None:
    """
    Flush the whole vectorstore which contains all project embeddings.

    :param path: Path to the grimoire project.
    """
    config = ProjectConfiguration.load_from_yaml(path / CONFIG_FILE_NAME)

    if not typer.confirm("Do you really want to flush the vectorstore?", default=False):
        raise typer.Abort()

    try:
        vectorstore = vectorstore_connection(config.db)
        delete_vectorstore(vectorstore)
    except psycopg.OperationalError as e:
        typer.echo(f"Error: {e}")
        raise e
    typer.echo("Vectorstore flushed")
</file>

<file path="grimoire/verify.py">
from pathlib import Path

import typer

from grimoire.configuration import CONFIG_FILE_NAME, ProjectConfiguration

verify_cli = typer.Typer()


@verify_cli.command("verify", help="Verify the configuration of the project")
def verify(
    path: Path = typer.Argument(  # noqa: B008
        Path.cwd(),  # noqa: B008
        help="Path to the grimoire project",
    ),
) -> None:
    """
    Verify the configuration of the project.

    :param path: Path to the grimoire project.
    """
    if not (path / CONFIG_FILE_NAME).exists():
        typer.echo("No configuration file found. Please run `grim init` first.")
        raise typer.Exit(code=1)
    typer.echo("Verifying configuration")
    config = ProjectConfiguration.load_from_yaml(path / CONFIG_FILE_NAME)
    prefix = typer.style("Successful for", fg=typer.colors.GREEN, bold=True)
    typer.echo(f"{prefix}: {config.name}")
</file>

<file path="sandbox/retrieval_chain.py">
import os
from collections.abc import Generator
from typing import cast

from helpers import setup_llm, setup_vectorstore
from langchain.prompts import ChatPromptTemplate, HumanMessagePromptTemplate
from langchain_core.messages import SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import (
    RunnableParallel,
    RunnablePassthrough,
    RunnableSerializable,
)
from langchain_core.vectorstores import VectorStore

SYSTEM_MESSAGE = """

Your name is grimoire. You are an AI assistent who helps with questions about code and projects.

Rules:
- Do not make up an answer if you do not know the answer, just say that you do not know the answer.
- Ask for clarification if the question is vague.
- If the context is not relevant, then answer with your best knowledge about the topic.
- If you answer with your best knowledge, then say it that the answer is based on your general knowledge.
- Answer the question shortly and clearly and do not provide too much information.
- Provide accurate, efficient, and maintainable code solutions.
- Promote secure coding practices and avoid security vulnerabilities.
- Do not copy proprietary or copyrighted code.
- Give credit when using open-source examples.
- Ensure fair, unbiased, and professional responses.
- Encourage best practices and explain concepts when needed.
- Do not store, misuse, or expose sensitive user data.
"""

PROMPT_TEMPLATE = """
Context: {context}

Question: {question}

Answer:
"""

# suppress grpc and glog logs
os.environ["GRPC_VERBOSITY"] = "ERROR"
os.environ["GLOG_MINLOGLEVEL"] = "2"


def build_retrieval_chain() -> RunnableSerializable:
    llm = setup_llm()

    vectorstore = setup_vectorstore("sandbox_text")
    vectorstore = cast(VectorStore, vectorstore)

    prompt = ChatPromptTemplate.from_messages(
        [
            SystemMessage(content=SYSTEM_MESSAGE),
            HumanMessagePromptTemplate.from_template(PROMPT_TEMPLATE),
        ]
    )
    ChatPromptTemplate.input_variables = ["context", "question"]

    retrieval = RunnableParallel(
        {  # type: ignore
            "context": vectorstore.as_retriever(),
            "question": RunnablePassthrough(),
        }
    )

    return retrieval | prompt | llm | StrOutputParser()


def stream_response(chain: RunnableSerializable, question: str) -> Generator:
    for chunk in chain.stream(question):
        if chunk is not None:
            yield chunk


if __name__ == "__main__":
    chain = build_retrieval_chain()

    question = "What is Vilko?"
    for chunk in stream_response(chain, question):
        print(chunk)

    question = "What happened to Strubelpeter?"
    for chunk in stream_response(chain, question):
        print(chunk)

    question = "How to create multi-page documentation in Markdown?"
    for chunk in stream_response(chain, question):
        print(chunk)
</file>

<file path="sandbox/text_ingestion_01.py">
from typing import cast

from helpers import clear_collection, setup_vectorstore
from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain_core.documents import Document
from langchain_postgres import PGVector
from langchain_text_splitters import RecursiveCharacterTextSplitter

TEXT_CHUNK_SIZE = 512
TEXT_CHUNK_OVERLAP = 128  # 20 - 30% Overlap


def ingest_text() -> None:
    clear_collection("sandbox_text")

    data = DirectoryLoader(
        path="files",
        glob="*.md",
        loader_cls=TextLoader,
    ).load()

    # Split Text in Chunks
    char_splitter = RecursiveCharacterTextSplitter(
        chunk_size=TEXT_CHUNK_SIZE,
        chunk_overlap=TEXT_CHUNK_OVERLAP,
        separators=["\n\n", "\n", " ", ""],  # Splits first by paragraphs, then lines
    )

    splits = []
    for document in data:
        splits.extend(char_splitter.split_text(document.page_content))

    documents = [Document(page_content=chunk) for chunk in splits]

    # Ingest into DB
    vectorstore = setup_vectorstore("sandbox_text")
    vectorstore = cast(PGVector, vectorstore)
    vectorstore.add_documents(documents)


if __name__ == "__main__":
    ingest_text()
</file>

<file path="sandbox/text_ingestion_02.py">
from typing import cast

from helpers import clear_collection, setup_vectorstore
from langchain_community.document_loaders import (
    DirectoryLoader,
    TextLoader,
    UnstructuredFileLoader,
)
from langchain_postgres import PGVector
from langchain_text_splitters import (
    MarkdownHeaderTextSplitter,
    RecursiveCharacterTextSplitter,
)

TEXT_CHUNK_SIZE = 512
TEXT_CHUNK_OVERLAP = 128  # 20 - 30% of chunk size

HEADERS = [
    ("#", "Heading 1"),
    ("##", "Heading 2"),
    ("###", "Heading 3"),
    ("####", "Heading 4"),
    ("#####", "Heading 5"),
]


def load_documents() -> list:
    file_types = ["*.txt", "*.md", "*.pdf", "*.docx"]
    data = []

    for file_type in file_types:
        if file_type in {"*.pdf", "*.docx"}:
            loader_cls = UnstructuredFileLoader  # type: ignore
        else:
            loader_cls = TextLoader  # type: ignore

        loader = DirectoryLoader(path="files", glob=file_type, loader_cls=loader_cls)
        data.extend(loader.load())

    return data


def ingest_text() -> None:
    clear_collection("sandbox_text")
    data = load_documents()

    # Markdown-Splitter
    splits = []
    md_splitter = MarkdownHeaderTextSplitter(
        headers_to_split_on=HEADERS, strip_headers=True
    )
    for document in data:
        splits.extend(md_splitter.split_text(document.page_content))

    # Recursive Character Splitter
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=512,
        chunk_overlap=128,
        separators=["\n\n", "\n", " "],
        length_function=len,
    )
    all_splits = text_splitter.split_documents(splits)

    # Ingest text into DB
    vectorstore = setup_vectorstore("sandbox_text")
    vectorstore = cast(PGVector, vectorstore)
    vectorstore.add_documents(all_splits)


if __name__ == "__main__":
    ingest_text()
</file>

<file path="tests/test_main.py">
from typer.testing import CliRunner

from grimoire import __version__
from grimoire.main import cli

runner = CliRunner()


def test_help_flag() -> None:
    result = runner.invoke(cli, ["--help"])
    assert result.exit_code == 0
    assert "grimoire [OPTIONS] COMMAND [ARGS]..." in result.stdout


def test_includes_commands() -> None:
    result = runner.invoke(cli, ["--help"])
    commands = ["ask", "flush", "init", "sync", "update", "verify", "version"]
    for command in commands:
        assert command in result.stdout


def test_command_version() -> None:
    result = runner.invoke(cli, ["version"])
    assert result.exit_code == 0
    assert f"grim cli v{__version__}" in result.stdout
</file>

<file path="grimoire/sync.py">
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import cast

import psycopg
import typer
from git import Repo
from langchain_postgres import PGVector
from rich.progress import track

from grimoire.configuration import CONFIG_FILE_NAME, ProjectConfiguration
from grimoire.helpers.ingestion import code_ingestion, text_ingestion
from grimoire.helpers.vectorstore import (
    clear_collection,
    setup_vectorstore,
    vectorstore_connection,
)

DEFAULT_EXCLUDE = [".git", ".venv", ".env", "sandbox"]
sync_cli = typer.Typer()


@sync_cli.command("sync", help="Sync the grimoire project with existing configuration")
def sync(
    path: Path = typer.Argument(  # noqa: B008
        Path.cwd(),  # noqa: B008
        help="Path to the grimoire project",
    ),
) -> None:
    """
    Sync the grimoire project with existing configuration and sources.

    :param path: Path to the grimoire project.
    """
    if not typer.confirm(
        f"Are you sure you want to sync the grimoire project at {path}?",
        default=False,
    ):
        raise typer.Abort()

    typer.echo("Syncing grimoire project")
    config = ProjectConfiguration.load_from_yaml(path / CONFIG_FILE_NAME)

    if not config.sources:
        typer.echo("No sources found in configuration file")
        raise typer.Abort()

    try:
        connection = vectorstore_connection(config.db)
        clear_collection(config.llm.collection, connection)
    except psycopg.OperationalError as e:
        typer.echo("Error connecting to the database")
        raise e

    vectorstore = setup_vectorstore(config.llm.collection, connection)
    vectorstore = cast(PGVector, vectorstore)  # hack to avoid mypy error

    if config.include_project:
        text_splits = text_ingestion(path, config.llm, exclude=DEFAULT_EXCLUDE)
        code_splits = code_ingestion(
            path, config.llm, glob=f"{config.project_src}/**/*"
        )
        vectorstore.add_documents(text_splits)
        vectorstore.add_documents(code_splits)

    for repo in track(config.sources, description="Processing sources"):
        if not repo.include_md and not repo.include_code:
            continue

        with TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            Repo.clone_from(repo.url, to_path=temp_path)

            if repo.include_md:
                text_splits = text_ingestion(temp_path, config.llm)
                vectorstore.add_documents(text_splits)

            if repo.include_code:
                code_splits = code_ingestion(temp_path, config.llm)
                vectorstore.add_documents(code_splits)
</file>

<file path="README.md">
<div align="center">
<a href="https://github.com/BDP25/grimoire">
<img src="images/logo.svg" alt="Logo" width="80" height="80">
</a>
<h3 align="center">grimoire</h3>
<p align="center">
Grimoire (gʀiˈmwaːʀ), a book (tool) of magical knowledge about your code and its dependencies.
<br/>
</p>
</div>

![Contributors](https://img.shields.io/github/contributors/BDP25/grimoire?color=dark-green)
![Issues](https://img.shields.io/github/issues/BDP25/grimoire)
![License](https://img.shields.io/github/license/BDP25/grimoire)

## Table of Contents

- [Table of Contents](#table-of-contents)
- [About the Project](#about-the-project)
- [Usage](#usage)
  - [Development](#development)
- [License](#license)
- [Contributors](#contributors)

## About the Project

Ever joined a new software project with an unfamiliar tech stack? You’re faced with internal libraries, legacy code, scattered documentation, and dependency-breaking
changes. Typically, you’d rely on docs, Stack Overflow, code exploration, and now LLMs like ChatGPT. But these tools don’t fully understand your project’s
context—frustrating, right?

That’s why we built Grimoire. It’s a powerful client tool that leverages RAG (Retrieval-Augmented Generation) to deeply understand your code, documentation,
dependencies, and project structure. Grimoire acts as your personal AI assistant, helping you onboard faster, develop smarter, and navigate your project with ease.

- 🔍 Deep Code Understanding – Grimoire analyzes your entire codebase for better insights.
- 📚 Seamless Documentation Access – No more searching; get the right info instantly.
- 🧩 Smart Dependency Mapping – Know how everything connects in your project.

## Usage

First create a new Gemini API key in the [Google AI Studio](https://aistudio.google.com/app/apikey) and save it as `LLM_API_KEY` in your environment.

```shell
export LLM_API_KEY=<your-api-key>
```

Start the local pgvector database:

```shell
docker compose up -d
```

Then you can use the `grim` client to interact with grimoire.

```shell
# with the uv project context
uv run grim --help

# or if you have installed the package
grim --help
```

```text
 Usage: grim [OPTIONS] COMMAND [ARGS]...

 A cli which enables RAG for your project 🔮
 Prequsites:
 - Get an LLM API token (e.g. from https://aistudio.google.com/app/apikey)
 - Set the LLM_API_TOKEN environment variable to the token

╭─ Options ────────────────────────────────────────────────────────────────────╮
│ --help          Show this message and exit.                                  │
╰──────────────────────────────────────────────────────────────────────────────╯
╭─ Commands ───────────────────────────────────────────────────────────────────╮
│ version   Print the version of the grim cli                                  │
│ ask       Ask a question with project context                                │
│ sync      Sync the grimoire project with existing configuration              │
│ verify    Verify the configuration of the project                            │
│ add       Add a new dependency or document to the project                    │
│ init      Initialize a new grimoire project                                  │
╰──────────────────────────────────────────────────────────────────────────────╯
```

### Development

The project is using [uv](https://docs.astral.sh/uv/) as the python project manager. In addition [Poe the Poet](https://poethepoet.natn.io/index.html) is used to run
tasks.

Some important uv commands:

```shell
# install pyproject dependencies
uv sync

# install a package
uv add <package>
uv add <package> --dev

# run a script
uv run python sandbox/text_ingestion.py

# run poe tasks
uv run poe all     # run all tasks
uv run poe format  # format code
uv run poe lint    # lint code
uv run poe types   # type check code
uv run poe test    # run tests
```

## License

Distributed under the MIT License. See [LICENSE.md](LICENSE.md) for more information.

## Contributors

See the [contributing guidelines](CONTRIBUTING.md) for more information.


**Project Authors:**

- Felix Céline (felixcel)
- Kiritharan Kirishana (kiritkir)
- Truninger John (trunijoh)

</br>
<a href="https://github.com/BDP25/grimoire/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=BDP25/grimoire" />
</a>
</file>

<file path="grimoire/main.py">
import typer

from grimoire import __version__
from grimoire.ask import ask_cli
from grimoire.flush import flush_cli
from grimoire.init import init_cli
from grimoire.sync import sync_cli
from grimoire.update import update_cli
from grimoire.verify import verify_cli

CLI_NAME = "grimoire"
DESCRIPTION = """
A cli which enables RAG for your project 🔮

Prequsites:\n
- Get an LLM API token (e.g. from https://aistudio.google.com/app/apikey)\n
- Set the LLM_API_TOKEN environment variable to the token\n
"""

cli = typer.Typer(
    name=CLI_NAME,
    help=DESCRIPTION,
    add_completion=False,
)

cli.add_typer(ask_cli, name=None)
cli.add_typer(flush_cli, name=None)
cli.add_typer(init_cli, name=None)
cli.add_typer(sync_cli, name=None)
cli.add_typer(update_cli, name=None)
cli.add_typer(verify_cli, name=None)


@cli.callback(invoke_without_command=True)
def main(
    ctx: typer.Context,
) -> None:
    """
    Gets called when no subcommand is provided and displays the help message.

    :param ctx: Typer context.
    """
    if ctx.invoked_subcommand is None:
        typer.echo(ctx.get_help())
        raise typer.Exit()


@cli.command("version", help="Print the version of the grim cli")
def version() -> None:
    """
    Print the version of the grim cli.
    """
    typer.echo(f"grim cli v{__version__}")
</file>

<file path="tests/test_init.py">
from typer.testing import CliRunner

from grimoire.init import init_cli

runner = CliRunner()


def test_init_creates_configuration(tmp_path) -> None:
    result = runner.invoke(
        init_cli,
        [str(tmp_path)],
        input="\n".join(
            [
                "test-project",
                "y",
                "grimoire",
                "localhost",
                "5432",
                "postgres",
                "pgvector",
                "pgvector",
                "mycollection",
            ]
        ),
    )
    assert result.exit_code == 0
    assert (tmp_path / "grimoire.yaml").is_file()
    assert "Grimoire project initialized successfully! 🎉" in result.stdout


def test_init_uses_default_values(tmp_path) -> None:
    result = runner.invoke(init_cli, [str(tmp_path)], input="\n" * 8)

    config_content = (tmp_path / "grimoire.yaml").read_text()
    assert result.exit_code == 0
    assert f"name: {tmp_path.name}" in config_content

    # db config
    assert "host: localhost" in config_content
    assert "port: 5432" in config_content
    assert "db: postgres" in config_content
    assert "user: pgvector" in config_content
    assert "password: pgvector" in config_content

    # llm config
    assert f"collection: {tmp_path.name}" in config_content
    assert "k_results: 5" in config_content
    assert "score_threshold: 0.8" in config_content
    assert "lambda_mult: 0.5" in config_content
    assert "text_chunk_size: 512" in config_content
    assert "text_chunk_overlap: 128" in config_content
    assert "code_chunk_size: 512" in config_content
    assert "code_chunk_overlap: 128" in config_content

    # project config
    assert "include_project: true" in config_content
    assert "project_src: " in config_content


def test_init_fails_on_nonexistent_path() -> None:
    result = runner.invoke(init_cli, ["./nonexistent"])
    assert result.exit_code == 1
    assert "Error: Path nonexistent does not exist" in result.stdout


def test_init_overwrite_existing_file(tmp_path) -> None:
    config = tmp_path / "grimoire.yaml"
    config.touch()

    result = runner.invoke(
        init_cli,
        [str(tmp_path)],
        input="\n".join(
            [
                "y",
                "test-project",
                "y",
                "grimoire",
                "localhost",
                "5432",
                "postgres",
                "pgvector",
                "pgvector",
                "mycollection",
            ]
        ),
    )
    assert result.exit_code == 0
    assert (tmp_path / "grimoire.yaml").is_file()
    assert "Grimoire project initialized successfully! 🎉" in result.stdout


def test_init_does_not_overwrite_when_declined(tmp_path) -> None:
    config = tmp_path / "grimoire.yaml"
    config.touch()
    config.write_text("existing content")

    result = runner.invoke(init_cli, [str(tmp_path)], input="N\n")
    assert result.exit_code == 0
    assert "Exiting without overwriting existing file" in result.stdout
    assert config.read_text() == "existing content"
</file>

<file path="sandbox/text_ingestion.py">
from typing import cast

from helpers import clear_collection, setup_vectorstore
from langchain_community.document_loaders import (
    DirectoryLoader,
    TextLoader,
)
from langchain_postgres import PGVector
from langchain_text_splitters.markdown import (
    MarkdownHeaderTextSplitter,
    RecursiveCharacterTextSplitter,
)

TEXT_CHUNK_SIZE = 512
TEXT_CHUNK_OVERLAP = 128  # 20 - 30% of chunk size
HEADERS = [
    ("#", "Heading 1"),
    ("##", "Heading 2"),
    ("###", "Heading 3"),
    ("####", "Heading 4"),
    ("#####", "Heading 5"),
]


def ingest_text() -> None:
    clear_collection("sandbox_text")
    data = DirectoryLoader(
        path="files",
        glob="*.md",
        loader_cls=TextLoader,
        loader_kwargs={"encoding": "UTF-8"},
    ).load()

    splits = []
    md_splitter = MarkdownHeaderTextSplitter(
        headers_to_split_on=HEADERS,
        strip_headers=True,
    )

    for document in data:
        for split in md_splitter.split_text(document.page_content):
            splits.append(split)

    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=TEXT_CHUNK_SIZE, chunk_overlap=TEXT_CHUNK_OVERLAP
    )
    all_splits = text_splitter.split_documents(splits)

    vectorstore = setup_vectorstore("sandbox_text")
    vectorstore = cast(PGVector, vectorstore)  # hack to avoid mypy error
    vectorstore.add_documents(all_splits)


if __name__ == "__main__":
    ingest_text()
</file>

<file path="grimoire.yaml">
name: grimoire
db:
  host: localhost
  port: 5432
  db: postgres
  user: pgvector
  password: pgvector
llm:
  collection: grimoire
  k_results: 5
  score_threshold: 0.8
  lambda_mult: 0.5
  text_chunk_size: 512
  text_chunk_overlap: 128
  code_chunk_size: 512
  code_chunk_overlap: 128
include_project: true
project_src: grimoire
sources:
  - url: https://github.com/pallets/flask
    include_md: true
    include_code: false
  - url: https://github.com/corydolphin/flask-cors
    include_md: true
    include_code: false
  - url: https://github.com/pallets-eco/flask-sqlalchemy
    include_md: true
    include_code: false
  - url: https://github.com/miguelgrinberg/Flask-Migrate
    include_md: true
    include_code: false
  - url: https://github.com/psf/requests
    include_md: true
    include_code: false
  - url: https://github.com/benoitc/gunicorn
    include_md: true
    include_code: false
</file>

<file path="grimoire/ask.py">
import os
from pathlib import Path
from typing import cast

import typer
from langchain_postgres import PGVector

from grimoire.configuration import CONFIG_FILE_NAME, ProjectConfiguration
from grimoire.helpers.llm import setup_llm
from grimoire.helpers.retriever import get_retrieval_chain
from grimoire.helpers.typer import red_text
from grimoire.helpers.vectorstore import setup_vectorstore, vectorstore_connection

ask_cli = typer.Typer()


@ask_cli.command("ask", help="Ask a question with project context")
def ask(
    question: list[str],
    skip_rag: bool = typer.Option(False, "--skip-rag", help="Skip the RAG process"),
    path: Path = typer.Option(  # noqa: B008
        Path.cwd(),  # noqa: B008
        "--path",
        help="Path to the grimoire project",
    ),
) -> None:
    """
    Ask a question either with or without the RAG process (--skip-rag flag).

    :param question: Question as a list of words.
    :param skip_rag: Flag to skip the RAG process and use only the LLM.
    :param path: Path to the grimoire project.
    """
    if not os.getenv("LLM_API_KEY"):
        typer.echo("LLM_API_KEY environment variable is not set.")
        raise typer.Abort()

    typer.echo(f"{red_text('Grimoire 🔮: ')}", nl=False)
    question_str = " ".join(question)

    llm = setup_llm()

    if skip_rag:
        for chunk in llm.stream(question_str):
            typer.echo(chunk.content, nl=False)

    else:
        config = ProjectConfiguration.load_from_yaml(path / CONFIG_FILE_NAME)

        connection = vectorstore_connection(config.db)
        vectorstore = setup_vectorstore(config.llm.collection, connection)
        vectorstore = cast(PGVector, vectorstore)

        rag_client = get_retrieval_chain(vectorstore, llm, config.llm)

        for chunk in rag_client.stream(question_str):
            typer.echo(chunk, nl=False)
</file>

<file path="grimoire/configuration.py">
from pathlib import Path

import yaml
from pydantic import BaseModel

CONFIG_FILE_NAME = "grimoire.yaml"


# see: https://stackoverflow.com/questions/25108581/python-yaml-dump-bad-indentation
class YamlDumper(yaml.Dumper):
    """
    Custom Yaml dumper for list indentation
    """

    def increase_indent(self, flow: bool = False, indentless: bool = False) -> None:
        return super().increase_indent(flow, False)


class LLMConfiguration(BaseModel):
    """
    Configuration for the LLM defined and used in the project.
    """

    collection: str
    k_results: int = 5
    score_threshold: float = 0.8
    lambda_mult: float = 0.5
    text_chunk_size: int = 512
    text_chunk_overlap: int = 128
    code_chunk_size: int = 512
    code_chunk_overlap: int = 128


class DBConfiguration(BaseModel):
    """
    Configuration for the database defined and used in the project.

    TODO: store password in a secure way!
    """

    host: str
    port: int
    db: str
    user: str
    password: str


class Source(BaseModel):
    """
    Representation of a text or code source in the project.
    """

    url: str
    include_md: bool = True
    include_code: bool = False


class ProjectConfiguration(BaseModel):
    name: str
    db: DBConfiguration
    llm: LLMConfiguration
    include_project: bool = True
    project_src: str | None = None
    sources: list[Source] | None = None

    @classmethod
    def load_from_yaml(cls, file_path: Path) -> "ProjectConfiguration":  # noqa: B008
        """
        Load the project configuration from a YAML file.

        :param file_path: Path to the YAML file.
        :return: ProjectConfiguration instance.
        """
        with open(file_path, encoding="utf-8") as f:
            return cls.model_validate(yaml.safe_load(f))

    def save_to_yaml(self, file_path: Path) -> None:
        """
        Save the project configuration to a YAML file.

        :param file_path: Path to the YAML file.
        """
        with open(file_path, "w", encoding="utf-8") as f:
            yaml.dump(
                data=self.model_dump(), stream=f, Dumper=YamlDumper, sort_keys=False
            )
</file>

<file path="grimoire/init.py">
from pathlib import Path

import typer

from grimoire.configuration import (
    CONFIG_FILE_NAME,
    DBConfiguration,
    LLMConfiguration,
    ProjectConfiguration,
    Source,
)
from grimoire.helpers.typer import green_text

init_cli = typer.Typer()

DUMMY_SOURCES = [
    Source(url="https://github.com/pallets/flask"),
    Source(url="https://github.com/corydolphin/flask-cors"),
    Source(url="https://github.com/pallets-eco/flask-sqlalchemy"),
    Source(url="https://github.com/miguelgrinberg/Flask-Migrate"),
    Source(url="https://github.com/psf/requests"),
    Source(url="https://github.com/benoitc/gunicorn"),
]


def get_project_config(path: Path) -> ProjectConfiguration:
    """
    Queries user input and returns full project configuration

    :param path: Path where configuration will be saved
    :return: ProjectConfiguration
    """
    project_name = typer.prompt("Project name", default=path.name)
    include_project = typer.confirm("Include project in embeddings?", default=True)
    project_src = typer.prompt(
        "What is the project src folder? (e.g. src, <project-name>)", default=path.name
    )

    db_config = DBConfiguration(
        host=typer.prompt("Database host", default="localhost"),
        port=typer.prompt("Database port", default="5432"),
        db=typer.prompt("Database name", default="postgres"),
        user=typer.prompt("Database user", default="pgvector"),
        password=typer.prompt("Database password", default="pgvector"),
    )

    ingestion_config = LLMConfiguration(
        collection=typer.prompt("Unique collection name", default=path.name)
    )

    return ProjectConfiguration(
        name=project_name,
        include_project=include_project,
        project_src=project_src,
        llm=ingestion_config,
        db=db_config,
        sources=DUMMY_SOURCES,  # TODO: add sources from dep files
    )


@init_cli.command("init", help="Initialize a new grimoire project")
def init(
    path: Path = typer.Argument(  # noqa: B008
        Path.cwd(),  # noqa: B008
        help="Path where grimoire project should be created",
    ),
) -> None:
    """
    Initialize a new grimoire project with questionaire.

    :param path: Path where grimoire project should be created.
    """
    file_path = path / CONFIG_FILE_NAME

    if not path.is_dir():
        typer.echo(f"Error: Path {path} does not exist", err=True)
        raise typer.Exit(code=1)
    if file_path.exists() and not typer.confirm(
        f"File {file_path} already exists. Overwrite?"
    ):
        typer.echo("Exiting without overwriting existing file")
        raise typer.Exit(code=0)

    config: ProjectConfiguration = get_project_config(path)
    config.save_to_yaml(file_path)

    success_message = f"""
    {green_text("Grimoire project initialized successfully! 🎉")}

    Configuration: {file_path}
    Note: directly modify the "{CONFIG_FILE_NAME}" configuration to your needs.
    """.strip()

    typer.echo(f"\n{success_message}\n")  # required for better formatting
</file>

<file path="pyproject.toml">
[project]
name = "grimoire"
version = "0.1.0"
description = "Add your description here"
license = { file = "LICENSE.md" }
readme = "README.md"
requires-python = "<3.13,>=3.12"

dependencies = [
    "datasets>=3.4.1",
    "esprima>=4.0.1",
    "gitpython>=3.1.44",
    "google-genai>=1.4.0",
    "grpcio==1.60.1",
    "langchain-postgres>=0.0.13",
    "langchain[community,huggingface,google-genai]>=0.3.20",
    "psycopg[binary]>=3.2.6",
    "pydantic>=2.10.6",
    "rich>=13.9.4",
    "sentence-transformers>=3.4.1",
    "torch>=2.6.0",
    "tree-sitter>=0.24.0",
    "tree-sitter-languages>=1.10.2",
    "typer>=0.15.2",
]

[dependency-groups]
dev = [
    "commitizen>=4.2.2",
    "coverage[toml]>=7.6.12",
    "mypy>=1.15.0",
    "poethepoet>=0.32.2",
    "pylint>=3.3.4",
    "pylint-junit>=0.3.5",
    "pytest>=8.3.4",
    "pytest-clarity>=1.0.1",
    "pytest-cov>=6.0.0",
    "pytest-deadfixtures>=2.2.1",
    "ruff>=0.9.8",
    "types-pyyaml>=6.0.12.20241230",
]

[project.scripts]
grim = "grimoire.main:cli"

[project.urls]
repository = "https://github.com/BDP25/grimoire"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.poe.tasks]
format = {shell = "ruff format && ruff check --fix"}
lint = {shell = "ruff check && pytest --dead-fixtures"}
types = {shell = "mypy ."}
test = {shell = "pytest"}
all = {shell = "poe format && poe lint && poe types && poe test && poe pylint"}

[tool.poe.tasks.pylint]
shell = "pylint -j 0 --recursive=y --output-format=${output_format} ${extra} ."
args = [
  { name = "output_format", options = ["--output-format"], default = "text" },
  { name = "extra", options = ["--extra"], default = "" }
]

[tool.mypy]
ignore_missing_imports = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_calls = true
exclude = [".venv/", "tests/", "conftest.py"]

[tool.pytest.ini_options]
addopts = "--cov . --cov-report term --cov-report html --cov-report xml --junitxml junit.xml"
filterwarnings = "ignore"
junit_family = "xunit2"

[tool.coverage.run]
omit = [".venv/*"]

[tool.ruff]
extend-exclude = ["**/migrations"]

[tool.ruff.lint]
extend-ignore = ["E501"]
select = [
  # pycodestyle
  "E",
  # Pyflakes
  "F",
  # pyupgrade
  "UP",
  # flake8-bugbear
  "B",
  # flake8-simplify
  "SIM",
  # isort
  "I",
]
</file>

</files>
